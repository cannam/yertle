
module store;

index = load index;

typedef triple = {
    s is URI string | Blank number,
    p is URI string,
    o is URI string | Blank number | Literal { value is string, type is string },
};

typedef pattern = {
    s is Wildcard () | URI string | Blank number,
    p is Wildcard () | URI string,
    o is Wildcard () | URI string | Blank number | Literal { value is string, type is string },
};

typedef store = {
    indexes is list<{ order is list<'a>, tree is hash<'b, 'c> }>,
};

newStore () = {
    indexes = [
        index.newIndex [ (.s), (.p), (.o) ],
        index.newIndex [ (.p), (.o), (.s) ],
        index.newIndex [ (.o), (.p), (.s) ],
    ];
};

add st t is store -> triple -> boolean =
    all id (map do ix: index.add ix t done st.indexes);

remove st t is store -> triple -> boolean = 
    all id (map do ix: index.remove ix t done st.indexes);

enumerate st is store -> list<'a> =
    index.enumerate (head st.indexes);

contains st t is store -> triple -> boolean = 
    // Doesn't matter which index we use to look up a complete triple
    index.contains (head st.indexes) t;

match st pat is store -> pattern -> list<triple> =
    index.match (index.chooseIndex st.indexes pat) pat;

{ newStore, add, remove, enumerate, contains, match }


