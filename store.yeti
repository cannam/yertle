
module store;

index = load index;

typedef statement = {
    s is URI string | Blank number,
    p is URI string,
    o is URI string | Blank number | Literal { value is string, type is string },
};

typedef pattern = {
    s is Wildcard () | URI string | Blank number,
    p is Wildcard () | URI string,
    o is Wildcard () | URI string | Blank number | Literal { value is string, type is string },
};

typedef store = {
    indexes is list<{ order is list<'a>, tree is hash<'b, 'c> }>,
};

newStore () = {
    indexes = [
        index.newIndex [ (.s), (.p), (.o) ],
        index.newIndex [ (.p), (.o), (.s) ],
        index.newIndex [ (.o), (.p), (.s) ],
    ];
};

add st stmt is store -> statement -> boolean =
    all id (map do ix: index.add ix stmt done st.indexes);

remove st stmt is store -> statement -> boolean = 
    all id (map do ix: index.remove ix stmt done st.indexes);

enumerate st is store -> list<'a> =
    index.enumerate (head st.indexes);

contains st stmt is store -> statement -> boolean = 
    // Doesn't matter which index we use to look up a complete statement
    index.contains (head st.indexes) stmt;

match st pat is store -> pattern -> list<statement> =
    index.match (index.chooseIndex st.indexes pat) pat;

{ newStore, add, remove, enumerate, contains, match }


