
module test.test_hashtree;

{ compare } = load test.test;

{ empty, addList, exactMatch, enumerate } = load hashtree;

// unordered compare
cmp a b = hash a == hash b;

// just so as to print out the discrepancy nicely if test fails
compareUnordered a b = if cmp a b then true else compare a b fi;

[

"cmp": \(
    // just check our cmp function works!
    cmp [1,2,3] [3,2,1] and
       not cmp [1,2,3] [3,2,0] and
       cmp [] [] and
       not cmp [1] [] and
       cmp [[1],[2]] [[2],[1]]
),

"empty": \(
    compareUnordered (enumerate (empty ())) [];
),

"simple": \(
    h = empty ();
    addList h [1,2,3] and
       compareUnordered (enumerate h) [[1,2,3]];
),

"identical": \(
    h = empty ();
    addList h [1,2,3] and
       addList h [1,2,3] and
       compareUnordered (enumerate h) [[1,2,3]];
),

"prefix": \(
    h = empty ();
    addList h [1,2,3] and
       not (addList h [1,2]) and
       not (addList h [1,2,3,4]);
),

"common": \(
    h = empty ();
    addList h [1,2,3] and
       addList h [1,2,4] and
       compareUnordered (enumerate h) [[1,2,3],[1,2,4]];
),

"differentLengths": \(
    h = empty ();
    addList h [1] and
       addList h [2,3] and
       addList h [3,4,5] and
       compareUnordered (enumerate h) [[1],[2,3],[3,4,5]];
),

"diverging": \(
    h = empty ();
    addList h [1,2,3] and
       addList h [1,2,4] and
       addList h [1,3,4] and
       addList h [1,3,5] and
       addList h [2,1] and
       addList h [2,2] and
       compareUnordered (enumerate h) [[1,2,3],[1,2,4],[1,3,4],[1,3,5],[2,1],[2,2]];
),

"exactMatch": \(
    h = empty ();
    addList h [1,2,3] and
       addList h [1,2,4] and
       addList h [1,3,4] and
       addList h [1,3,5] and
       addList h [2,1] and
       addList h [2,2] and
       exactMatch h [2,1] and
       not exactMatch h [1,3] and
       exactMatch h [1,3,4] and
       not exactMatch h [1,2,3,4] and
       not exactMatch h []
),

"addEmpty": \(
    not (addList (empty ()) []);
),

] is hash<string, () -> boolean>;

