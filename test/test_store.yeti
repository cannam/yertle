
module test.test_store;

{ compare, compareUnordered } = load test.test;

{ newStore, add, remove, enumerate, contains, match } = load yertle.store;

triple a b c = [ "s" : IRI a, "p" : IRI b, "o" : IRI c ];

testTriple n =
    case n of
    "aaa": triple "fred" "loves" "cheese";
    "aab": triple "fred" "loves" "fruit";
    "abc": triple "fred" "hates" "vinegar";
    "bba": triple "jodie" "hates" "cheese";
    "bca": triple "jodie" "tolerates" "fred";
    _: triple "this" "shouldn't" "happen";
    esac;

testWildcard n =
    case n of
    "***": [:];
    "aa*": [ "s" : IRI "fred", "p" : IRI "loves" ];
    "a**": [ "s" : IRI "fred" ];
    "*a*": [ "p" : IRI "loves" ];
    "a*a": [ "s" : IRI "fred", "o" : IRI "cheese" ];
    "**a": [ "o" : IRI "cheese" ];
    _: [:];
    esac;

[

"empty": \(
    compareUnordered (enumerate (newStore ())) [];
),

"simple": \(
    h = newStore ();
    add h (testTriple "aaa") and
       compareUnordered (enumerate h) [testTriple "aaa"];
),

"duplicate": \(
    h = newStore ();
    add h (testTriple "aaa") and
       add h (testTriple "aaa") and
       compareUnordered (enumerate h) [testTriple "aaa"];
),

"common": \(
    h = newStore ();
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       compareUnordered (enumerate h) [testTriple "aaa",testTriple "aab"];
),

"diverging": \(
    h = newStore ();
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       compareUnordered (enumerate h)
           [(testTriple "aaa"),
            (testTriple "aab"),
            (testTriple "abc"),
            (testTriple "bba")];
),

"contains": \(
    h = newStore ();
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       contains h (testTriple "aaa") and
       contains h (testTriple "aab") and
       contains h (testTriple "abc") and
       contains h (testTriple "bba") and
       not contains h (testTriple "bca")
),

"remove": \(
    h = newStore ();
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       contains h (testTriple "aaa") and
       remove h (testTriple "aaa") and
       not contains h (testTriple "aaa") and // not there after removing
       not remove h (testTriple "aaa") and // and can't remove again
       remove h (testTriple "bba") and
       not remove h (testTriple "bca")
),

"match": \(
    h = newStore ();
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       compareUnordered (enumerate h) (match h (testWildcard "***")) and
       compareUnordered (match h (testWildcard "**a"))
          [testTriple "aaa", testTriple "bba"]
),

] is hash<string, () -> boolean>;

