
module test.test_index;

{ compare } = load test.test;

{ newIndex, add, remove, enumerate, contains, match, scoreIndexFor, chooseIndex } = load index;

// unordered compare
cmp a b = hash a == hash b;

// just so as to print out the discrepancy nicely if test fails
compareUnordered a b = if cmp a b then true else compare a b fi;

triple a b c = { s = URI a, p = URI b, o = URI c };

testTriple n =
    case n of
    "aaa": triple "fred" "loves" "cheese";
    "aab": triple "fred" "loves" "fruit";
    "abc": triple "fred" "hates" "vinegar";
    "bba": triple "jodie" "hates" "cheese";
    "bca": triple "jodie" "tolerates" "fred";
    _: triple "this" "shouldn't" "happen";
    esac;

testWildcard n =
    case n of
    "***": { s = Wildcard (), p = Wildcard (), o = Wildcard () };
    "aa*": { s = URI "fred", p = URI "loves", o = Wildcard () };
    "a**": { s = URI "fred", p = Wildcard (), o = Wildcard () };
    "*a*": { s = Wildcard (), p = URI "loves", o = Wildcard () };
    "a*a": { s = URI "fred", p = Wildcard (), o = URI "cheese" };
    "**a": { s = Wildcard (), p = Wildcard (), o = URI "cheese" };
    _: { s = Wildcard (), p = Wildcard (), o = Wildcard () };
    esac;

indexNames = [ "spo", "pos", "ops", "sop", "pso", "osp" ];

indexType n =
    case n of
    "spo": SPO ();
    "pos": POS ();
    "ops": OPS ();
    "sop": Other [ (.s), (.o), (.p) ];
    "pso": Other [ (.p), (.s), (.o) ];
    "osp": Other [ (.o), (.s), (.p) ];
    _: Other [];
    esac;

preliminaries =
[

"cmp": \(
    // just check our cmp function works!
    cmp [1,2,3] [3,2,1] and
       not cmp [1,2,3] [3,2,0] and
       cmp [] [] and
       not cmp [1] [] and
       cmp [[1],[2]] [[2],[1]]
),

];

perIndex name type =
[

"\(name)-empty": \(
    compareUnordered (enumerate (newIndex type)) [];
),

"\(name)-simple": \(
    h = newIndex type;
    add h (testTriple "aaa") and
       compareUnordered (enumerate h) [testTriple "aaa"];
),

"\(name)-duplicate": \(
    h = newIndex type;
    add h (testTriple "aaa") and
       add h (testTriple "aaa") and
       compareUnordered (enumerate h) [testTriple "aaa"];
),

"\(name)-common": \(
    h = newIndex type;
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       compareUnordered (enumerate h) [testTriple "aaa",testTriple "aab"];
),

"\(name)-diverging": \(
    h = newIndex type;
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       compareUnordered (enumerate h)
           [(testTriple "aaa"),
            (testTriple "aab"),
            (testTriple "abc"),
            (testTriple "bba")];
),

"\(name)-contains": \(
    h = newIndex type;
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       contains h (testTriple "aaa") and
       contains h (testTriple "aab") and
       contains h (testTriple "abc") and
       contains h (testTriple "bba") and
       not contains h (testTriple "bca")
),

"\(name)-remove": \(
    h = newIndex type;
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       contains h (testTriple "aaa") and
       remove h (testTriple "aaa") and
       not contains h (testTriple "aaa") and // not there after removing
       not remove h (testTriple "aaa") and // and can't remove again
       remove h (testTriple "bba") and
       not remove h (testTriple "bca")
),

"\(name)-match": \(
    h = newIndex type;
    add h (testTriple "aaa") and
       add h (testTriple "aab") and
       add h (testTriple "abc") and
       add h (testTriple "bba") and
       compareUnordered (enumerate h) (match h (testWildcard "***")) and
       compareUnordered (match h (testWildcard "**a"))
          [testTriple "aaa", testTriple "bba"]
),

];

testIndexFor ixs patstr ixstrs =
   (ix = chooseIndex ixs (testWildcard patstr);
    contains? ix (map do n: newIndex (indexType n) done ixstrs) or
       (println "** for \(testWildcard patstr)\n   expected: one of \(ixstrs)\n   obtained: \(ix.order)"; false));

discriminatory =
[

"scoreIndex": \(
    h = newIndex (OPS ());
    compare (scoreIndexFor (testWildcard "**a") h) 16 and
        compare (scoreIndexFor (testWildcard "a*a") h) 20 and
        compare (scoreIndexFor (testWildcard "aa*") h) 12
),

"chooseIndexFromAll": \(
    ixs = map do n: newIndex (indexType n) done indexNames;
    testIndexFor ixs "aa*" ["spo","pso"] and
        testIndexFor ixs "a**" ["spo","sop"] and
        testIndexFor ixs "aaa" indexNames and
        testIndexFor ixs "a*a" ["sop","osp"] and
        testIndexFor ixs "***" indexNames and
        testIndexFor ixs "*a*" ["pso","pos"]
),

"chooseIndexFromSet": \(
    ixs = map do n: newIndex (indexType n) done ["spo","pos","ops"];
    testIndexFor ixs "aa*" ["spo"] and
        testIndexFor ixs "a**" ["spo"] and
        testIndexFor ixs "aaa" ["spo","pos","ops"] and
        testIndexFor ixs "a*a" ["ops", "spo"] and
        testIndexFor ixs "***" ["spo","pos","ops"] and
        testIndexFor ixs "*a*" ["pos"]
),

];

all = [:];

for (concat [[preliminaries],
             map do n: perIndex n (indexType n) done indexNames,
             [discriminatory]],) do h:
    for (keys h) do k: all[k] := h[k] done
done;

all is hash<string, () -> boolean>;

