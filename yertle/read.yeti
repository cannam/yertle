
module yertle.read;

/*
   RDF/Turtle parser.
  
   Parser functions return Error "error text" | OK someValue, where
   someValue is itself a tagged variant type.

   The ~> operator defined in parsebits.yeti (evaluate the left side,
   pass result to the right side if it was OK something, or else
   return the error) is used extensively for control flow.

   Only partially constructed triples are returned as values from
   functions: when a triple is completed, it is "emitted" and added to
   the pending triples in the state object rather than being returned.
   (This is necessary because there may be individual parse tokens
   that result in emitting more than one triple -- such as collection
   elements.)
*/

char = load yertle.char;
store = load yertle.store;

load yertle.parsebits;

import java.lang: Character;

xsdPrefix = "http://www.w3.org/2001/XMLSchema#";
rdfPrefix = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";

rdfTypeIRI  = IRI "\(rdfPrefix)type";
rdfFirstIRI = IRI "\(rdfPrefix)first";
rdfRestIRI  = IRI "\(rdfPrefix)rest";
rdfNilIRI   = IRI "\(rdfPrefix)nil";

rangePNBase   = "A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF" ^
                "\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D" ^
                "\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF" ^
                "\\uF900-\\uFDCF\\uFDF0-\\uFFFD";

rePNCharsBase = "[\(rangePNBase)]";
rePNCharsU    = "[\(rangePNBase)_]";
rePNChars     = "[\(rangePNBase)_0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040-]";
rePNPrefix    = "\(rePNCharsBase)" ^
                "(?:(?:\(rePNChars)|\\.)*" ^
                "\(rePNChars))?";
reBlank       = "(?:\(rePNCharsU)|[0-9])" ^
                "(?:(?:\(rePNChars)|\\.)*" ^
                "(?:\(rePNChars)))?";
rePercent     = "(?:%[0-9A-Fa-f][0-9A-Fa-f])";
rePNLocalEsc  = "(?:\\\\[_~.!$&'()*+,;=/?#@%-])";
rePlx         = "\(rePercent)|\(rePNLocalEsc)";
rePNLocal     = "(?:(?:\(rePNCharsU)|[0-9:]|\(rePlx))" ^
                "(?:(?:\(rePNChars)|\\.|:|\(rePlx))*" ^
                "(?:\(rePNChars)|:|\(rePlx)))?)?";

likeAZ        = like "^[a-zA-Z]*";
likeAZLower   = like "^[a-z]*";
likeIRIPart   = like "^[^\\x00-\\x20<>\"{}|^`\\\\]*";
likeSlashU    = like "^\\\\[Uu]";

likeShortString quote = like "^[^\\x5c\\x0a\\x0d\(quote)]*";
likeShortStringEscape = like "^\\\\[tbnrf\\\\\"']";

likeNumber    = like "^[0-9eE+-]*";
likeAfterDec  = like "^\\.[0-9eE]";

matchE        = (=~ "[Ee]");
matchPNPrefix = (=~ "^\(rePNPrefix)$");
matchBlank    = (=~ "^\(reBlank)$");
matchNonLit   = (=~ "[_(\\[<:\(rePNCharsBase)]");

matchAllPName = matchAll "^(\(rePNPrefix))?:(\(rePNLocal))$" M T;

likeSparqlBase = like "^[Bb][Aa][Ss][Ee][ \t]";
likeSparqlPfx = like "^[Pp][Rr][Ee][Ff][Ii][Xx][ \t]";

newLiteral string = { value = string, type = "", language = "" };

punctuation expected state =
    noseq state [whitespace, required expected];

havePunctuation expected state =
   (chomp state; state.reader.next == expected);

unicodeEscape state =
    required "\\" state ~>
      \(n = case state.reader.next of "u": 4; "U": 8; _: 0 esac;
        if n == 0 then Error "Expected \\U or \\u at \(state.reader.location)";
        else 
            state.reader.discard ();
            OK (Token (fold do a b: a ^ state.reader.read () done "" [1..n]));
        fi ~>
           \case of
            Token t:
                try OK (Token (strJoin "" Character#toChars(number "0x\(t)")));
                catch NumberFormatException _:
                    Error "Expected \(n)-character hex at \(state.reader.location)";
                catch IllegalArgumentException _:
                    Error "Escaped character out of range at \(state.reader.location)";
                yrt
            esac
        );

backslashEscape state = 
    required "\\" state ~>
      \(escapes = [ 't': "\t", 'b': "\b", 'n': "\n", 'r': "\r", 'f': "\f",
                    '\': '\', '"': '"', "'": "'" ];
        if state.reader.next in escapes then
            OK (Token escapes[state.reader.read ()]);
        else
            Error "Unknown escape sequence at \(state.reader.location)"
        fi);

emit state triple =
    push state.pendingTriples triple;

emitWithSubject state subject polist =
   (for polist do po: emit state { s = subject, p = po.p, o = po.o } done;
    OK (Empty ()));

langtag state =
   (langtag' state = 
       (tag = state.reader.readMatch likeAZ;
        if state.reader.next == "-" then
            tag ^ state.reader.read () ^ langtag' state
        else
            tag
        fi);
    tokseq state [required "@", OK . Token . langtag']);

iriref state =
   (iriref' acc state =
       (part = state.reader.readMatch likeIRIPart;
        if state.reader.lookingAt likeSlashU then
            unicodeEscape state ~>
               \case of
                Token u: iriref' (acc ^ part ^ u) state;
                esac;
        else
            OK (Token (acc ^ part));
        fi);
    tokseq state [required "<",
                  iriref' "",
                  required ">"]);

pnameCandidate state =
   (pnameCandidate' escaped acc r =
        if r.isWhitespace then
            OK (Token acc)
        elif strIndexOf "#.;,)]" r.next 0 >= 0 and not escaped then
            OK (Token acc)
        else
            escaped = (r.next == '\');
            pnameCandidate' escaped (acc ^ r.read ()) r;
        fi;
    pnameCandidate' false "" state.reader);

pnameNS state =
    pnameCandidate state ~>
       \case of
        Token t:
            if strEnds? t ":" then
                pfx = strLeft t ((strLength t) - 1);
                if pfx == "" or matchPNPrefix pfx then
                    OK (Token pfx)
                else
                    Error "Malformed prefix '\(pfx)' at \(state.reader.location)"
                fi
            else
                Error "Expected ':' at end of prefix before \(state.reader.location)"
            fi
        esac;
               
base state = 
    tokseq state [ whitespace, iriref, punctuation "." ] ~>
       \case of
        Token iri: 
            state.base := iri;
            OK (Empty ());
        esac;
                    
prefix state =
    tokseq state [ whitespace, pnameNS ] ~>
       \case of Token pname:
            tokseq state [whitespace, iriref, punctuation "."] ~>
               \case of Token iri:
                    state.namespaces[pname] := iri;
                    OK (Empty ());
                esac;
        esac;
       
sparqlBase state =
    pnameCandidate state ~>
       \case of
        Token t:
            if (strLower t) == "base" then
                tokseq state [ whitespace, iriref ] ~>
                   \case of
                    Token iri: 
                        state.base := iri;
                        OK (Empty ());
                    esac;
            else
                Error "Expected BASE at \(state.reader.location)";
            fi
        esac;

sparqlPrefix state =
    pnameCandidate state ~>
       \case of
        Token t:
            if (strLower t) == "prefix" then
                tokseq state [ whitespace, pnameNS ] ~>
                   \case of
                    Token pname:
                        tokseq state [ whitespace, iriref ] ~>
                           \case of
                            Token iri: 
                                state.namespaces[pname] := iri;
                                OK (Empty ());
                            esac;
                    esac;
            else
                Error "Expected PREFIX at \(state.reader.location)";
            fi
        esac;

directive state =
    case state.reader.next of
    "@": langtag state ~>
            \case of
             Token "prefix": prefix state;
             Token "base": base state;
             Token t: Error "Expected base or prefix, found '\(t)' at \(state.reader.location)";
             esac;
    "B": sparqlBase state;
    "b": sparqlBase state;
    "P": sparqlPrefix state;
    "p": sparqlPrefix state;
      _: Error "Expected @base, @prefix, BASE, or PREFIX at \(state.reader.location)";
    esac;

booleanType =
    "\(xsdPrefix)boolean";

newBoolLiteral b =
    Literal (newLiteral (if b then "true" else "false" fi) with { type = booleanType });

// Assumes local is known to match the pname local escapes patterns
// (i.e. if it has any escapes, they will have enough characters in
// the escaped data)
unescapeLocal local =
   (unescapeLocal' acc local =
        if local == "" then acc
        elif strStarts? local "%" then
            hex = "0x\(strSlice local 1 3)";
            unescapeLocal' (acc ^ (strJoin "" Character#toChars(number hex)))
                (strRight local 3);
        elif strStarts? local "\\" then
            //!!! Not implemented yet
            unescapeLocal' (acc ^ strLeft local 1) (strRight local 1);
        else
            unescapeLocal' (acc ^ strLeft local 1) (strRight local 1);
        fi;
    unescapeLocal' "" local);

prefixExpanded state text =
    case matchAllPName text of
    [M [whole, prefix, local]]:
        if prefix in state.namespaces then
            try
                OK (IRI (state.namespaces[prefix] ^ unescapeLocal local));
            catch NumberFormatException _:
                Error "Malformed escape in local name '\(local)' before \(state.reader.location)";
            yrt
        else
            Error "Unknown namespace prefix '\(prefix)' at \(state.reader.location)";
        fi;
    _: Error "Malformed prefixed name '\(text)' at \(state.reader.location)";
    esac;

prefixedName state =
    pnameCandidate state ~>
       \case of
        // We can't tell the difference, until we get here, between a
        // prefixed name and the bare keywords true or false
        Token t:
            if t == "true" then OK (newBoolLiteral true);
            elif t == "false" then OK (newBoolLiteral false);
            else prefixExpanded state t;
            fi;
        esac;

aOrPrefixedName state =
    pnameCandidate state ~>
       \case of
        Token "a": OK rdfTypeIRI;
        Token t: prefixExpanded state t;
        esac;

newBlankNode state =
    Blank state.newBlankNodeId;

blankNodeFor state b =
   (if not b in state.bnodeLabels then
        state.bnodeLabels[b] := newBlankNode state;
    fi;
    state.bnodeLabels[b]);

blank state =
    tokseq state [required '_', required ':', pnameCandidate] ~>
       \case of
        Token b:
            if matchBlank b then
                OK (blankNodeFor state b)
            else
                Error "Malformed blank node label '\(b)' at \(state.reader.location)";
            fi;
        esac;

// resolve cyclical dependency
// object -> nonLiteralObject -> collection -> object
// and
// object -> nonLiteralObject -> blankNodePropertyList -> objectList -> object
var object' state =
    Error "object' should have been reassigned";

// [15] collection ::= '(' object* ')'
//!!! This could be simpler
collection state =
   (readObjects acc state =
        if havePunctuation ")" state then
            OK acc
        else
            object' state ~> do obj: readObjects (acc ++ [obj]) state done
        fi;
    addObjects node state objects =
        case objects of
        obj::rest:
           (emit state { s = node, p = rdfFirstIRI, o = obj };
            if empty? rest then
                emit state { s = node, p = rdfRestIRI, o = rdfNilIRI };
            else
                nextNode = newBlankNode state;
                emit state { s = node, p = rdfRestIRI, o = nextNode };
                addObjects nextNode state rest;
            fi);
        _: ();
        esac;
    required "(" state ~>
       \(readObjects [] state ~>
            do objects:
            case objects of
            []: required ")" state ~> \(OK rdfNilIRI);
             _:
               (headnode = newBlankNode state;
                addObjects headnode state objects;
                required ")" state ~> \(OK headnode));
            esac done));

// [135s] iri ::= IRIREF | PrefixedName
iri state =
    case state.reader.next of
    "<": iriref state ~> \case of Token t: OK (IRI t); esac;
      _: prefixedName state;
    esac;

// [9] verb ::= predicate | 'a'
// where
// [11] predicate ::= iri
verb state =
    case state.reader.next of
    "<": iri state;
      _: aOrPrefixedName state;
    esac;

// [10] subject ::= iri | blank
subject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
      _: iri state;
    esac ~>
       \case of
        Literal _: Error "Literal not permitted as subject at \(state.reader.location)";
        IRI iri: OK (IRI iri);
        Blank b: OK (Blank b);
        esac;

datatype state =
    required "^" state ~> \(required "^" state) ~> \(iri state);

// [133s] BooleanLiteral ::= 'true' | 'false'
booleanLiteral state =
   (lit = state.reader.readMatch likeAZLower;
    if lit == "true" then OK (newBoolLiteral true);
    elif lit == "false" then OK (newBoolLiteral false);
    else Error "Expected 'true' or 'false' at \(state.reader.location)";
    fi);

openQuote state =
   (r = state.reader;
    quote = r.next;
    if quote != "\"" and quote != "'" then
        Error "Expected quotation mark at \(state.reader.location)";
    else
        if (r.discard (); r.next == quote) then
            if (r.discard (); r.next == quote) then
                r.discard ();
                OK (Long quote); // three quotes: long string opening
            else
                OK (Empty ()); // two quotes: empty string
            fi
        else
            OK (Short quote); // one quote: short string opening
        fi
    fi);

longStringBody quote state =
   (longStringBody' quote n acc r =
        if r.next == quote then
            if n == 2 then // this is the third quote in a row, ends the string
                r.discard ();
                OK (Token (strLeft acc (strLength acc - 2)));
            else
                longStringBody' quote (n + 1) (acc ^ r.read ()) r
            fi
        elif r.isEof then
            Error "End of file reached in long string"
        else
            longStringBody' quote 0 (acc ^ r.read ()) r
        fi;
    longStringBody' quote 0 "" state.reader);

shortStringBody quote state =
   (shortStringBody' matcher acc state =
       (text = state.reader.readMatch matcher;
        if state.reader.lookingAt likeSlashU then
            unicodeEscape state ~>
               \case of
                Token t: shortStringBody' matcher (text ^ acc ^ t) state;
                esac
        elif state.reader.lookingAt likeShortStringEscape then
            backslashEscape state ~>
               \case of
                Token t: shortStringBody' matcher (text ^ acc ^ t) state;
                esac
        else 
            OK (Token (text ^ acc))
        fi);
    tokseq state [ shortStringBody' (likeShortString quote) "", required quote ]);

stringBody state =
    openQuote state ~>
       \case of
        Empty ():
            OK (Token "");
        Short q:
            shortStringBody q state;
        Long q:
            longStringBody q state;
        esac;

rdfLiteral state =
    stringBody state ~>
       \case of
        Token t:
            case state.reader.next of
            "@": langtag state ~>
                   \case of Token lt:
                        OK (Literal (newLiteral t with { language = lt }));
                    esac;
            "^": datatype state ~>
                   \case of
                    IRI di:
                        OK (Literal (newLiteral t with { type = di }));
                    _: // e.g. boolean literal, or base/prefix
                        Error "Malformed datatype IRI at \(state.reader.location)";
                    esac;
              _: OK (Literal (newLiteral t));
            esac;
        esac;

numericCandidate state =
   (n = state.reader.readMatch likeNumber;
    if state.reader.lookingAt likeAfterDec then
        state.reader.discard ();
        nn = state.reader.readMatch likeNumber;
        OK (Token (n ^ "." ^ nn));
    else
        OK (Token n);
    fi);

// Adapt the Turtle numeric literal syntax into something that Yeti's
// string to number conversion will like
parseableNumber n =
    if strStarts? n "+." then "0" ^ (strRight n 1)
    elif strStarts? n "+" then strRight n 1
    elif strStarts? n "." then "0" ^ n
    else n
    fi;

numericLiteral state =
    try
        numericCandidate state ~> 
           \case of
            Token n:
                type = if matchE n then "\(xsdPrefix)double"
                       elif strIndexOf n "." 0 >= 0 then "\(xsdPrefix)decimal"
                       else "\(xsdPrefix)integer"
                       fi;
                num = number (parseableNumber n);
                OK (Literal (newLiteral "\(num)" with { type }));
            esac;
    catch NumberFormatException _:
        Error "Malformed numeric literal at \(state.reader.location)";
    catch IllegalArgumentException _: // happens if token is empty
        Error "Expected numeric literal at \(state.reader.location)";
    yrt;

// [13] literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
literal state =
    case state.reader.next of
    "'": rdfLiteral state;
    '"': rdfLiteral state;   // "
    "t": booleanLiteral state;
    "f": booleanLiteral state;
      _: numericLiteral state;
    esac;

// resolve cyclical dependency
// blankNodePropertyList -> predicateObjectList -> objectList -> object -> nonLiteralObject -> blankNodePropertyList
var blankNodePropertyList' state = 
    Error "blankNodePropertyList' should have been reassigned";

nonLiteralObject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
    "[": blankNodePropertyList' state;
      _: iri state;
    esac;

// [12] object ::= iri | blank | blankNodePropertyList | literal

object state =
    if matchNonLit state.reader.next then
        nonLiteralObject state;
    else
        literal state;
    fi;

object' := object;

// [8] objectList ::= object (',' object)*
//!!! not tail-recursive
objectList state =
   (chomp state;
    object state ~>
        do obj:
            if havePunctuation "," state then
               (state.reader.discard ();
                objectList state ~>
                   \case of Nodes nodes:
                        OK (Nodes (obj::nodes));
                    esac);
            else
                OK (Nodes [obj]);
            fi;
        done
    );

// [7] predicateObjectList ::= 	verb objectList (';' (verb objectList)?)*
// NB we permit an empty list here; caller must reject if its rule
// demands predicateObjectList rather than predicateObjectList?
predicateObjectList state =
   (predicateObjectList' acc state =
        if havePunctuation "." state or havePunctuation "]" state then
            OK (POList acc) // empty list, or ending with ; .
        else
            verb state ~>
               \case of
                IRI iri:
                    objectList state ~>
                       \case of Nodes nodes:
                            OK (POList (acc ++
                                        map do n: { p = IRI iri, o = n } done
                                            nodes));
                        esac;
                _: // e.g. boolean literal
                    Error "Expected IRI before \(state.reader.location)";
                esac ~>
                   \case of POList lst:
                        if havePunctuation ";" state then
                            havePunctuation ";" state loop state.reader.discard ();
                            predicateObjectList' lst state
                        else
                            OK (POList lst)
                        fi
                    esac;
        fi;
    predicateObjectList' [] state);

// blankNodePropertyList ::= '[' predicateObjectList ']'
blankNodePropertyList state =
    punctuation "[" state ~>
      \(predicateObjectList state ~>
           \case of POList polist:
               (bnode = newBlankNode state;
                emitWithSubject state bnode polist ~>
                   \(punctuation "]" state) ~>
                       \(OK bnode));
            esac;
        );

blankNodePropertyList' := blankNodePropertyList;

// [6] triples ::= subject predicateObjectList |
//                 blankNodePropertyList predicateObjectList?
//
// Handles the blankNodePropertyList part of that alternation
blankNodeTriples state = 
    blankNodePropertyList state ~> 
        do subj:
            predicateObjectList state ~>
               \case of POList polist:
                    emitWithSubject state subj polist;
                esac
        done;

// [6] triples ::= subject predicateObjectList |
//                 blankNodePropertyList predicateObjectList?
// 
// Handles the subject part of that alternation
subjectTriples state =
    subject state ~> 
        do subj:
            predicateObjectList state ~>
               \case of
                POList []:
                    Error "Predicate required after subject at \(state.reader.location)";
                POList polist:
                    emitWithSubject state subj polist;
                esac
        done;

triples state = 
    case state.reader.next of
    "[": blankNodeTriples state;
      _: subjectTriples state;
    esac;

// [2] statement ::= directive | triples '.'
statement state =
   (chomp state;
    if state.reader.isEof then End ()
    elif state.reader.next == "@" then
        directive state;
    elif state.reader.lookingAt likeSparqlBase or
         state.reader.lookingAt likeSparqlPfx then
        directive state;
    else
        triples state ~> \(punctuation "." state);
    fi);

document state =
   (result = statement state;
    tt = map Triple state.pendingTriples;
    clearArray state.pendingTriples;
    case result of
    OK (Empty ()): (Triples tt) :. \(document state);
    Error e: [Error e];
    End _: [];
    esac);

// Flatten out [Triples [Triple, ...], Triples [Triple, ...], Error ...]
// into [Triple ..., Triple ..., Error ...]
flattened doc currentTriples =
    case currentTriples of
    t::tt:
        t :. \(flattened doc tt);
    _:
        case doc of
        element::ee:
            case element of
            Error e: [Error e];
            Triples chunk: flattened ee chunk;
            esac;
        _: [];
        esac;
    esac;

newState reader =
   (var nextBnode = 0;
    {
        reader,
        var base = "",
        pendingTriples = array [],
        namespaces = [:],
        bnodeLabels = [:],
        get newBlankNodeId () =
           (nextBnode := nextBnode + 1;
            nextBnode);
    });

parse reader =
    flattened (document (newState reader)) [];

parseHandle handle = 
    parse (char.reader handle);

parseFile filename = 
    parse (char.reader (openInFile filename "UTF-8")); // Turtle is always utf8

//!!! load to new store. loading into an existing store depends on proper global handling of blank nodes, which is still pending
loadFile filename = 
   (st = store.newStore ();
    fold
        do acc item:
            case acc of
            Error e: Error e;
            OK ():
                case item of
                Error e: Error e;
                Triple t:
                    if store.add st t then OK ()
                    else Error "Add failed for triple \(t)" fi;
                esac
            esac   
        done
        (OK ())
        (parseFile filename)
    ~> \(Store st));

{ parseHandle, parseFile, loadFile }
