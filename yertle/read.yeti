
module yertle.read;

char = load yertle.char;
store = load yertle.store;

load yertle.parsebits;

import java.lang: Character;

xsdPrefix = "http://www.w3.org/2001/XMLSchema#";
rdfPrefix = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
rdfTypeIRI  = IRI "\(rdfPrefix)type";
rdfFirstIRI = IRI "\(rdfPrefix)first";
rdfRestIRI  = IRI "\(rdfPrefix)rest";
rdfNilIRI   = IRI "\(rdfPrefix)nil";

newLiteral string = { value = string, type = "", language = "" };

punctuation expected state =
    noseq state [whitespace, required expected];

havePunctuation expected state =
   (chomp state; state.reader.next == expected);

azMatcher   = (=~ "[a-z]");
azAZMatcher = (=~ "[a-zA-Z]");

// Regexes for prefix:local matching
pnBaseRange = "A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
pnCharsBase = "[\(pnBaseRange)]";
pnCharsU    = "[\(pnBaseRange)_]";
pnChars     = "[\(pnBaseRange)_0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040-]";
pnPrefix    = "\(pnCharsBase)(?:(?:\(pnChars)|\\.)*\(pnChars))?";
bnode       = "(?:\(pnCharsU)|[0-9])(?:(?:\(pnChars)|\\.)*(?:\(pnChars)))?";
percent     = "(?:%[0-9A-Fa-f][0-9A-Fa-f])";
pnLocalEsc  = "(?:\\\\[_~.!$&'()*+,;=/?#@%-])";
plx         = "\(percent)|\(pnLocalEsc)";
pnLocal     = "(?:(?:\(pnCharsU)|[0-9:]|\(plx))(?:(?:\(pnChars)|\\.|:|\(plx))*(?:\(pnChars)|:|\(plx)))?)?";

unicodeEscape state =
    required "\\" state ~>
      \(n = case state.reader.next of "u": 4; "U": 8; _: 0 esac;
        if n == 0 then Error "Expected \\U or \\u at \(state.reader.location)";
        else 
            state.reader.discard ();
            OK (Token (fold do a b: a ^ state.reader.read () done "" [1..n]));
        fi ~>
           \case of
            Token t:
                try OK (Token (strJoin "" Character#toChars(number "0x\(t)")));
                catch NumberFormatException _:
                    Error "Expected \(n)-character hex at \(state.reader.location)";
                catch IllegalArgumentException _:
                    Error "Escaped character out of range at \(state.reader.location)";
                yrt
            esac
        );

backslashEscape state =
    required "\\" state ~>
      \(res = case state.reader.next of
         "t": OK (Token "\t");
         "b": OK (Token "\b");
         "n": OK (Token "\n");
         "r": OK (Token "\r");
         "f": OK (Token "\f");
        "\"": OK (Token "\"");
         "'": OK (Token  "'");
           _: Error "Expected one of tbrf\"' after \\ at \(state.reader.location)";
       esac;
       state.reader.discard ();
       res);

emit state triple =
    push state.pendingTriples triple;

emitWithSubject state subject polist =
   (for polist do po: emit state { s = subject, p = po.p, o = po.o } done;
    OK (Empty ()));

langtag state =
   (sub state = 
        case greedy azAZMatcher state of
        OK (Token tag):
            if state.reader.next == "-" then
                tag ^ state.reader.read () ^ sub state
            else
                tag
            fi;
        esac;
        tokseq state [required "@", OK . Token . sub]);


iriref state =
    tokseq state [required "<",
                  greedy (=~ '[^\x00-\x20<>"{}|^`\\]'),   //"
                  required ">"];

pnameCandidate state =
   (sub escaped acc r =
        if r.isWhitespace then
            OK (Token acc)
        elif (r.next == '#' or r.next == "." or
              r.next == ";" or r.next == "," or
              r.next == ")" or r.next == "]") 
             and not escaped then
            OK (Token acc)
        else
            escaped = (r.next == '\');
            sub escaped (acc ^ r.read ()) r;
        fi;
    sub false "" state.reader);

pnameNS state =
    pnameCandidate state ~>
       \case of
        Token t:
            if strEnds? t ":" then
                pfx = strLeft t ((strLength t) - 1);
                if pfx == "" or pfx =~ "^\(pnPrefix)$" then
                    OK (Token pfx)
                else
                    Error "Malformed prefix '\(pfx)' at \(state.reader.location)"
                fi
            else
                Error "Expected ':' at end of prefix before \(state.reader.location)"
            fi
        esac;
                   
prefix state =
    tokseq state [ whitespace, pnameNS ] ~>
       \case of Token pname:
            tokseq state [whitespace, iriref, punctuation "."] ~>
               \case of Token iri:
                    state.namespaces[pname] := iri;
                    OK (Empty ());
                esac;
        esac;
               
base state = 
    tokseq state [whitespace, iriref, punctuation "."] ~>
       \case of
        Token iri: 
            state.base := iri;
            OK (Empty ());
        esac;

sparqlPrefix state =
    tokseq state [ whitespace, pnameNS ] ~>
       \case of Token pname:
            tokseq state [whitespace, iriref] ~>
               \case of Token iri:
                    state.namespaces[pname] := iri;
                    OK (Empty ());
                esac;
        esac;
        
sparqlBase state =
    tokseq state [whitespace, iriref] ~>
       \case of
        Token iri: 
            state.base := iri;
            OK (Empty ());
        esac;

directive state =
    langtag state ~>
       \case of
        Token "prefix": prefix state;
        Token "base": base state;
        Token t: Error "Expected prefix or base, found '\(t)'";
        esac;

booleanType =
    "\(xsdPrefix)boolean";

newBoolLiteral b =
    Literal (newLiteral (if b then "true" else "false" fi) with { type = booleanType });

matchPrefixedName =
    matchAll "^(\(pnPrefix))?:(\(pnLocal))$" M T;

// Assumes local is known to match the pname local escapes patterns
// (i.e. if it has any escapes, they will have enough characters in
// the escaped data)
expandPNLocalEscapes local =
   (sub acc local =
        if local == "" then acc
        elif strStarts? local "%" then
            hex = "0x\(strSlice local 1 3)";
            sub (acc ^ (strJoin "" Character#toChars(number hex)))
                (strRight local 3);
        elif strStarts? local "\\" then
            //!!! Not implemented yet
            sub (acc ^ strLeft local 1) (strRight local 1);
        else
            sub (acc ^ strLeft local 1) (strRight local 1);
        fi;
    sub "" local);

prefixExpanded state text =
    case matchPrefixedName text of
    [M [whole, prefix, local]]:
        if prefix in state.namespaces then
            try
                OK (IRI (state.namespaces[prefix] ^ expandPNLocalEscapes local));
            catch NumberFormatException _:
                Error "Malformed escape in local name '\(local)' before \(state.reader.location)";
            yrt
        else
            Error "Unknown namespace prefix '\(prefix)' at \(state.reader.location)";
        fi;
    _: Error "Malformed prefixed name '\(text)' at \(state.reader.location)";
    esac;

prefixedName state =
    pnameCandidate state ~>
       \case of
        // We can't tell the difference, until we get here, between a
        // prefixed name and the bare keywords true, false, base, or prefix
        Token t:
            if t == "true" then OK (newBoolLiteral true);
            elif t == "false" then OK (newBoolLiteral false);
            elif t =~ "^[Bb][Aa][Ss][Ee]$" then OK (BaseLabel ());
            elif t =~ "^[Pp][Rr][Ee][Ff][Ii][Xx]$" then OK (PrefixLabel ());
            else prefixExpanded state t;
            fi;
        esac;

aOrPrefixedName state =
    pnameCandidate state ~>
       \case of
        Token "a": OK rdfTypeIRI;
        Token t: prefixExpanded state t;
        esac;

newBlankNode state =
    Blank state.newBlankNodeId;

blankNodeFor state b =
   (if not b in state.bnodeLabels then
        state.bnodeLabels[b] := newBlankNode state;
    fi;
    state.bnodeLabels[b]);

blank state =
    tokseq state [required '_', required ':', pnameCandidate] ~>
       \case of
        Token b:
            if b =~ "^\(bnode)$" then
                OK (blankNodeFor state b)
            else
                Error "Malformed blank node label '\(b)' at \(state.reader.location)";
            fi;
        esac;

//!!! cyclical dependency
// object -> nonLiteralObject -> collection -> object
// and
// object -> nonLiteralObject -> blankNodePropertyList -> objectList -> object
var object' state =
    Error "object' should have been reassigned";

// [15] collection ::= '(' object* ')'
//!!! This could be simpler
collection state =
   (readObjects acc state =
        if havePunctuation ")" state then
            OK acc
        else
            object' state ~> do obj: readObjects (acc ++ [obj]) state done
        fi;
    addObjects node state objects =
        case objects of
        obj::rest:
           (emit state { s = node, p = rdfFirstIRI, o = obj };
            if empty? rest then
                emit state { s = node, p = rdfRestIRI, o = rdfNilIRI };
            else
                nextNode = newBlankNode state;
                emit state { s = node, p = rdfRestIRI, o = nextNode };
                addObjects nextNode state rest;
            fi);
        _: ();
        esac;
    required "(" state ~>
       \(readObjects [] state ~>
            do objects:
            case objects of
            []: required ")" state ~> \(OK rdfNilIRI);
             _:
               (headnode = newBlankNode state;
                addObjects headnode state objects;
                required ")" state ~> \(OK headnode));
            esac done));

// [135s] iri ::= IRIREF | PrefixedName
iri state =
    case state.reader.next of
    "<": iriref state ~> \case of Token t: OK (IRI t); esac;
      _: prefixedName state;
    esac;

// [9] verb ::= predicate | 'a'
// where
// [11] predicate ::= iri
verb state =
    case state.reader.next of
    "<": iri state;
      _: aOrPrefixedName state;
    esac;

// [10] subject ::= iri | blank
subject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
      _: iri state;
    esac ~>
       \case of
        BaseLabel (): OK (BaseLabel ());
        PrefixLabel (): OK (PrefixLabel ());
        Literal _: Error "Literal not permitted as subject at \(state.reader.location)";
        other: OK (Node other);
        esac;

datatype state =
    required "^" state ~> \(required "^" state) ~> \(iri state);

// [133s] BooleanLiteral ::= 'true' | 'false'
booleanLiteral state =
    greedy azMatcher state ~>
       \case of 
        Token  "true": OK (newBoolLiteral true);
        Token "false": OK (newBoolLiteral false);
        _: Error "Expected 'true' or 'false' at \(state.reader.location)";
        esac;

openQuote state =
   (r = state.reader;
    quote = r.next;
    if quote != "\"" and quote != "'" then
        Error "Expected quotation mark at \(state.reader.location)";
    else
        if (r.discard (); r.next == quote) then
            if (r.discard (); r.next == quote) then
                r.discard ();
                OK (Long quote); // three quotes: long string opening
            else
                OK (Empty ()); // two quotes: empty string
            fi
        else
            OK (Short quote); // one quote: short string opening
        fi
    fi);

longStringBody quote state =
   (sub quote n acc r =
        if r.next == quote then
            if n == 2 then // this is the third quote in a row, ends the string
                r.discard ();
                OK (Token (strLeft acc (strLength acc - 2)));
            else
                sub quote (n + 1) (acc ^ r.read ()) r
            fi
        elif r.isEof then
            Error "End of file reached in long string"
        else
            sub quote 0 (acc ^ r.read ()) r
        fi;
    sub quote 0 "" state.reader);

shortStringMatcher quote = (=~ "[^\\x5c\\x0a\\x0d\(quote)]");

shortStringBody quote state =
   (sub matcher acc state =
        if matcher state.reader.next then
            sub matcher (acc ^ (state.reader.read ())) state;
        elif state.reader.next == "\\" then
            if state.reader.nextButOne =~ "[Uu]" then
                unicodeEscape state ~>
                   \case of
                    Token t: sub matcher (acc ^ t) state;
                    esac
            elif state.reader.nextButOne =~ "[tbnrf\"']" then
                backslashEscape state ~>
                   \case of
                    Token t: sub matcher (acc ^ t) state;
                    esac
            else 
                OK (Token acc)
            fi
        else
            OK (Token acc)
        fi;
    tokseq state [ sub (shortStringMatcher quote) "", required quote ]);

stringBody state =
    openQuote state ~>
       \case of
        Empty ():
            OK (Token "");
        Short q:
            shortStringBody q state;
        Long q:
            longStringBody q state;
        esac;

rdfLiteral state =
    stringBody state ~>
       \case of
        Token t:
            case state.reader.next of
            "@": langtag state ~>
                   \case of Token lt:
                        OK (Literal (newLiteral t with { language = lt }));
                    esac;
            "^": datatype state ~>
                   \case of
                    IRI di:
                        OK (Literal (newLiteral t with { type = di }));
                    _: // e.g. boolean literal, or base/prefix
                        Error "Malformed datatype IRI at \(state.reader.location)";
                    esac;
              _: OK (Literal (newLiteral t));
            esac;
        esac;

numericalMatcher = (=~ "[0-9eE+-]");
numAfterDotMatcher = (=~ "[0-9eE]");

numericCandidate state =
    greedy numericalMatcher state ~>
       \case of
        Token n:
            if state.reader.next == "." and
               numAfterDotMatcher state.reader.nextButOne then
                state.reader.discard ();
                greedy numericalMatcher state ~>
                   \case of
                    Token nn: OK (Token (n ^ "." ^ nn));
                    esac;
            else
                OK (Token n);
            fi;
        esac;

// Adapt the Turtle numeric literal syntax into something that Yeti's
// string to number conversion will like
parseableNumber n =
    if strStarts? n "+" then
        if strStarts? n "+." then
            "0" ^ (strRight n 1)
        else
            strRight n 1
        fi
    elif strStarts? n "." then
        "0" ^ n
    else
        n
    fi;

numericLiteral state =
    try
        numericCandidate state ~> 
           \case of
            Token n:
                type = if n =~ "[Ee]" then "\(xsdPrefix)double"
                       elif n =~ "\\." then "\(xsdPrefix)decimal"
                       else "\(xsdPrefix)integer"
                       fi;
                num = number (parseableNumber n);
                OK (Literal (newLiteral "\(num)" with { type }));
            esac;
    catch NumberFormatException _:
        Error "Malformed numeric literal at \(state.reader.location)";
    catch IllegalArgumentException _: // happens if token is empty
        Error "Expected numeric literal at \(state.reader.location)";
    yrt;

// [13] literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
literal state =
    case state.reader.next of
    "'": rdfLiteral state;
    '"': rdfLiteral state;   // "
    "t": booleanLiteral state;
    "f": booleanLiteral state;
      _: numericLiteral state;
    esac;

//!!! cyclical dependency
// blankNodePropertyList -> predicateObjectList -> objectList -> object -> nonLiteralObject -> blankNodePropertyList
var blankNodePropertyList' state = 
    Error "blankNodePropertyList' should have been reassigned";

nonLiteralObject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
    "[": blankNodePropertyList' state;
      _: iri state;
    esac ~> (OK . Node);

// [12] object ::= iri | blank | blankNodePropertyList | literal

nonLiteralMatcher = (=~ "[_(\\[<:\(pnCharsBase)]");

object state =
    if nonLiteralMatcher state.reader.next then
        nonLiteralObject state
    else
        literal state ~> (OK . Node)
    fi;

object' := object;

// [8] objectList ::= object (',' object)*
//!!! not tail-recursive
objectList state =
   (chomp state;
    object state ~>
       \case of Node obj:
            if havePunctuation "," state then
               (state.reader.discard ();
                objectList state ~>
                   \case of Nodes nodes:
                        OK (Nodes (obj::nodes));
                    esac);
            else
                OK (Nodes [obj]);
            fi;
        esac
    );

// [7] predicateObjectList ::= 	verb objectList (';' (verb objectList)?)*
// NB we permit an empty list here; caller must reject if its rule
// demands predicateObjectList rather than predicateObjectList?
predicateObjectList state =
   (sub acc state =
        if havePunctuation "." state or havePunctuation "]" state then
            OK (POList acc) // empty list, or ending with ; .
        else
            verb state ~>
               \case of
                IRI iri:
                    objectList state ~>
                       \case of Nodes nodes:
                            OK (POList (acc ++
                                        map do n: { p = IRI iri, o = n } done
                                            nodes));
                        esac;
                _: // e.g. boolean literal, base/prefix
                    Error "Expected IRI before \(state.reader.location)";
                esac ~>
                   \case of POList lst:
                        if havePunctuation ";" state then
                           (state.reader.discard ();
                            havePunctuation ";" state) loop ();
                            sub lst state
                        else
                            OK (POList lst)
                        fi
                    esac;
        fi;
    sub [] state);

// blankNodePropertyList ::= '[' predicateObjectList ']'
blankNodePropertyList state =
    punctuation "[" state ~>
      \(predicateObjectList state ~>
           \case of POList polist:
               (bnode = newBlankNode state;
                emitWithSubject state bnode polist ~>
                   \(punctuation "]" state) ~>
                       \(OK (Node bnode)));
            esac;
        );

blankNodePropertyList' := blankNodePropertyList;

// [6] triples ::= subject predicateObjectList | blankNodePropertyList predicateObjectList?
// Handles the blankNodePropertyList part of that alternation
blankNodeTriples state = 
    blankNodePropertyList state ~> 
       \case of Node subj:
            predicateObjectList state ~>
               \case of POList polist:
                    emitWithSubject state subj polist;
                esac;
        esac ~> \(punctuation "." state);

// [6] triples ::= subject predicateObjectList | blankNodePropertyList predicateObjectList?
// Handles the subject part of that alternation
subjectTriples state =
    subject state ~> 
       \case of
        Node subj:
            predicateObjectList state ~>
               \case of
                POList []:
                    Error "Predicate required after subject at \(state.reader.location)";
                POList polist:
                    emitWithSubject state subj polist;
                esac ~> \(punctuation "." state);
        BaseLabel ():
            sparqlBase state ~> \(OK (Empty ()));
        PrefixLabel ():
            sparqlPrefix state ~> \(OK (Empty ()));
        esac;

triples state = 
    case state.reader.next of
    "[": blankNodeTriples state;
      _: subjectTriples state;
    esac;

// [2] statement ::= directive | triples '.'
statement state =
   (chomp state;
    if state.reader.isEof then End ()
    else
        case state.reader.next of
        "@": directive state;
          _: triples state;
        esac;
    fi);

document state =
   (result = statement state;
    tt = map Triple state.pendingTriples;
    clearArray state.pendingTriples;
    case result of
    OK (Empty ()): (Triples tt) :. \(document state);
    Error e: [Error e];
    End _: [];
    esac);

// Flatten out [Triples [Triple, ...], Triples [Triple, ...], Error ...]
// into [Triple ..., Triple ..., Error ...]
flattened doc currentTriples =
    case currentTriples of
    t::tt:
        t :. \(flattened doc tt);
    _:
        case doc of
        element::ee:
            case element of
            Error e: [Error e];
            Triples chunk: flattened ee chunk;
            esac;
        _: [];
        esac;
    esac;

newState reader =
   (var nextBnode = 0;
    {
        reader,
        var base = "",
        pendingTriples = array [],
        namespaces = [:],
        bnodeLabels = [:],
        get newBlankNodeId () =
           (nextBnode := nextBnode + 1;
            nextBnode);
    });

parse reader =
    flattened (document (newState reader)) [];

parseHandle handle = 
    parse (char.reader handle);

parseFile filename = 
    parse (char.reader (openInFile filename "UTF-8")); // Turtle is always utf8

//!!! load to new store. loading into an existing store depends on proper global handling of blank nodes, which is still pending
loadFile filename = 
   (st = store.newStore ();
    fold
        do acc item:
            case acc of
            Error e: Error e;
            OK ():
                case item of
                Error e: Error e;
                Triple t:
                    if store.add st t then OK ()
                    else Error "Add failed for triple \(t)" fi;
                esac
            esac   
        done
        (OK ())
        (parseFile filename)
    ~> \(Store st));

{ parseHandle, parseFile, loadFile }
