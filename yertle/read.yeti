
module yertle.read;

char = load yertle.char;
store = load yertle.store;

load yertle.parsebits;

xsdPrefix = "http://www.w3.org/2001/XMLSchema#";
rdfPrefix = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
rdfTypeIRI  = IRI "\(rdfPrefix)type";
rdfFirstIRI = IRI "\(rdfPrefix)first";
rdfRestIRI  = IRI "\(rdfPrefix)rest";
rdfNilIRI   = IRI "\(rdfPrefix)nil";

newLiteral string = { value = string, type = "", language = "" };

punctuation expected state =
    noseq state [whitespace, required expected];

langtag state =
   (sub state = 
        case greedy "[a-zA-Z]" state of
        OK (Token tag):
            if state.reader.next == "-" then
                tag ^ state.reader.read () ^ sub state
            else
                tag
            fi;
        esac;
        tokseq state [required "@", OK . Token . sub]);

iriref state =
    tokseq state [required "<",
                  greedy "[^\\x00-\\x20<>\"{}|^`\\\\]", //!!! " or UCHAR
                  required ">"];

// REs for prefix:local matching. Does not yet handle PLX (rule 169s)

pnBaseRange = "A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";

//!!! NB Yeti docs say it will optimise REs made from constant
//strings: how should we take advantage of that?
pnCharsBase = "[\(pnBaseRange)]";
pnCharsU    = "[\(pnBaseRange)_]";
pnChars     = "[\(pnBaseRange)_0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040-]";
pnPrefix    = "\(pnCharsBase)(?:(?:\(pnChars)|\\.)*\(pnChars))?";
bnode       = "(?:\(pnCharsU)|[0-9])(?:(?:\(pnChars)|\\.)*(?:\(pnChars)))?";
pnLocal     = "(?:\(pnCharsU)|[0-9:])(?:(?:\(pnChars)|\\.|:)*(?:\(pnChars)|:))?"; //!!! needs PLX
pname       = "(\(pnPrefix))?:(\(pnLocal))"; // NB this ?: is not like the rest

emit state triple =
    push state.pendingTriples triple;

emitWithSubject state subject polist =
   (for polist do po: emit state { s = subject, p = po.p, o = po.o } done;
    OK ());

pnameCandidate state =
   (sub r escaped acc =
        if r.isWhitespace then
            OK (Token acc)
        elif (r.next == '#' or r.next == "." or r.next == ";" or r.next == ",") 
             and not escaped then
            OK (Token acc)
        else
            escaped = (r.next == '\');
            sub r escaped (acc ^ r.read ());
        fi;
    sub state.reader false "");

pnameNS state =
    pnameCandidate state ~>
       \case of
        Token t:
            if strEnds? t ":" then
                pfx = strLeft t ((strLength t) - 1);
                if pfx == "" or pfx =~ "^\(pnPrefix)$" then
                    OK (Token pfx)
                else
                    Error "Malformed prefix '\(pfx)' at \(state.reader.location)"
                fi
            else
                Error "Expected ':' at end of prefix before \(state.reader.location)"
            fi
        esac;
                   
prefix state =
    tokseq state [ whitespace, pnameNS ] ~>
       \case of Token pname:
            tokseq state [whitespace, iriref, punctuation "."] ~>
               \case of Token iri:
                    state.namespaces[pname] := iri;
                    OK (Empty ());
                esac;
        esac;
               
base state = 
    tokseq state [whitespace, iriref, punctuation "."] ~>
       \case of
        Token iri: 
            state.base := iri;
            OK (Empty ());
        esac;

sparqlPrefix state =
    tokseq state [ whitespace, pnameNS ] ~>
       \case of Token pname:
            tokseq state [whitespace, iriref] ~>
               \case of Token iri:
                    state.namespaces[pname] := iri;
                    OK (Empty ());
                esac;
        esac;
        
sparqlBase state =
    tokseq state [whitespace, iriref] ~>
       \case of
        Token iri: 
            state.base := iri;
            OK (Empty ());
        esac;

directive state =
    langtag state ~>
       \case of
        Token "prefix": prefix state;
        Token "base": base state;
        Token t: Error "Expected prefix or base, found '\(t)'";
        esac;

booleanType =
    "\(xsdPrefix)boolean";

newBoolLiteral b =
    Literal (newLiteral (if b then "true" else "false" fi) with { type = booleanType });

prefixExpanded state text =
    case matchAll "^\(pname)$" M T text of
    [M [whole, prefix, local]]:
        if prefix in state.namespaces then
            OK (IRI (state.namespaces[prefix] ^ local));
        else
            Error "Unknown namespace prefix '\(prefix)' at \(state.reader.location)";
        fi;
    _: Error "Malformed prefixed name '\(text)' at \(state.reader.location)";
    esac;

prefixedName state =
    pnameCandidate state ~>
       \case of
        // We can't tell the difference, until we get here, between a
        // prefixed name and the bare keywords true, false, base, or prefix
        Token t:
            if t == "true" then OK (newBoolLiteral true);
            elif t == "false" then OK (newBoolLiteral false);
            elif t =~ "^[Bb][Aa][Ss][Ee]$" then OK (BaseLabel ());
            elif t =~ "^[Pp][Rr][Ee][Ff][Ii][Xx]$" then OK (PrefixLabel ());
            else prefixExpanded state t;
            fi;
        esac;

aOrPrefixedName state =
    pnameCandidate state ~>
       \case of
        Token "a": OK rdfTypeIRI;
        Token t: prefixExpanded state t;
        esac;

newBlankNode state =
    Blank state.newBlankNodeId;

blankNodeFor state b =
   (if not b in state.bnodeLabels then
        state.bnodeLabels[b] := newBlankNode state;
    fi;
    state.bnodeLabels[b]);

blank state =
    tokseq state [required '_', required ':', pnameCandidate] ~>
       \case of
        Token b:
            if b =~ "^\(bnode)$" then
                OK (blankNodeFor state b)
            else
                Error "Malformed blank node label '\(b)' at \(state.reader.location)";
            fi;
        esac;

//!!! cyclical dependency
// object -> nonLiteralObject -> collection -> object
// and
// object -> nonLiteralObject -> blankNodePropertyList -> objectList -> object
var object' state =
    Error "object' should have been reassigned";

// [15] collection ::= '(' object* ')'
//!!! This could be simpler
collection state =
   (readObjects acc state =
       (chomp state;
        if state.reader.next == ")" then
            OK acc
        else
            object' state ~> do obj: readObjects (acc ++ [obj]) state done
        fi);
    addObjects node state objects =
        case objects of
        obj::rest:
           (emit state { s = node, p = rdfFirstIRI, o = obj };
            if empty? rest then
                emit state { s = node, p = rdfRestIRI, o = rdfNilIRI };
            else
                nextNode = newBlankNode state;
                emit state { s = node, p = rdfRestIRI, o = nextNode };
                addObjects nextNode state rest;
            fi);
        _: ();
        esac;
    required "(" state ~>
       \(readObjects [] state ~>
            do objects:
            case objects of
            []: required ")" state ~> \(OK rdfNilIRI);
             _:
               (headnode = newBlankNode state;
                addObjects headnode state objects;
                required ")" state ~> \(OK headnode));
            esac done));

// [135s] iri ::= IRIREF | PrefixedName
iri state =
    case state.reader.next of
    "<": iriref state ~> \case of Token t: OK (IRI t); esac;
      _: prefixedName state;
    esac;

// [9] verb ::= predicate | 'a'
// where
// [11] predicate ::= iri
verb state =
    case state.reader.next of
    "<": iri state;
      _: aOrPrefixedName state;
    esac;

// [10] subject ::= iri | blank
subject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
      _: iri state;
    esac ~>
       \case of
        BaseLabel (): OK (BaseLabel ());
        PrefixLabel (): OK (PrefixLabel ());
        other: OK (Node other);
        esac;

datatype state =
    required "^" state ~> \(required "^" state) ~> \(iri state);

// [133s] BooleanLiteral ::= 'true' | 'false'
booleanLiteral state =
    greedy "[a-z]" state ~>
       \case of 
        Token  "true": OK (newBoolLiteral true);
        Token "false": OK (newBoolLiteral false);
        _: Error "Expected 'true' or 'false' at \(state.reader.location)";
        esac;

openQuote state =
   (r = state.reader;
    quote = r.next;
    if quote != "\"" and quote != "'" then
        Error "Expected quotation mark at \(state.reader.location)";
    else
        if (r.discard (); r.next == quote) then
            if (r.discard (); r.next == quote) then
                r.discard ();
                OK (Long quote); // three quotes: long string opening
            else
                OK (Empty ()); // two quotes: empty string
            fi
        else
            OK (Short quote); // one quote: short string opening
        fi
    fi);

longString state quote =
   (sub r quote acc n =
        if r.next == quote then
            if n == 2 then // this is the third quote in a row, ends the string
                r.discard ();
                OK (Token (strLeft acc (strLength acc - 2)));
            else
                sub r quote (acc ^ r.read ()) (n + 1)
            fi
        elif r.isEof then
            Error "End of file reached in long string"
        else
            sub r quote (acc ^ r.read ()) 0
        fi;
    sub state.reader quote "" 0);

stringBody state =
    openQuote state ~>
       \case of
        Empty ():
            OK (Token "");
        Short q:
            tokseq state [ greedy "[^\\x5c\\x0a\\x0d\(q)]", required q ];
        Long q:
            longString state q;
        esac;

//!!! still does not handle escapes, \u etc
rdfLiteral state =
    stringBody state ~>
       \case of
        Token t:
            case state.reader.next of
            "@": langtag state ~>
                   \case of Token lt:
                        OK (Literal (newLiteral t with { language = lt }));
                    esac;
            "^": datatype state ~>
                   \case of
                    IRI di:
                        OK (Literal (newLiteral t with { type = di }));
                    _: // e.g. boolean literal, or base/prefix
                        Error "Malformed datatype IRI at \(state.reader.location)";
                    esac;
              _: OK (Literal (newLiteral t));
            esac;
        esac;

// Currently using Java's number parser rather than Turtle rules (I
// wonder what the difference is)
numericLiteral state =
    try
        greedy '[0-9eE+\.-]' state ~> 
           \case of
            Token ".":
                Error "Expected literal at \(state.reader.location)";
            Token n:
                type = if n =~ "[Ee]" then "\(xsdPrefix)double"
                       elif n =~ "\\." then "\(xsdPrefix)decimal"
                       else "\(xsdPrefix)integer"
                       fi;
                num =
                    if strStarts? n "+" then
                        number (strRight n 1)
                    else
                        number n
                    fi;
                OK (Literal (newLiteral "\(num)" with { type }));
            esac;
    catch NumberFormatException _:
        Error "Malformed numeric literal at \(state.reader.location)";
    catch IllegalArgumentException _: // happens if token is empty
        Error "Expected numeric literal at \(state.reader.location)";
    yrt;

// [13] literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
literal state =
    case state.reader.next of
    "'": rdfLiteral state;
    '"': rdfLiteral state;   // "
    "t": booleanLiteral state;
    "f": booleanLiteral state;
      _: numericLiteral state;
    esac;

//!!! cyclical dependency
// blankNodePropertyList -> predicateObjectList -> objectList -> object -> nonLiteralObject -> blankNodePropertyList
var blankNodePropertyList' state = 
    Error "blankNodePropertyList' should have been reassigned";

nonLiteralObject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
    "[": blankNodePropertyList' state;
      _: iri state;
    esac ~> (OK . Node);

// [12] object ::= iri | blank | blankNodePropertyList | literal
object state =
    if state.reader.next =~ "[_(\\[<:\(pnCharsBase)]" then
        nonLiteralObject state
    else
        literal state ~> (OK . Node)
    fi;

object' := object;

// [8] objectList ::= object (',' object)*
//!!! not tail-recursive
objectList state =
   (chomp state;
    object state ~>
       \case of Node obj:
            if (chomp state; state.reader.next == ",") then
               (state.reader.discard ();
                objectList state ~>
                   \case of Nodes nodes:
                        OK (Nodes (obj::nodes));
                    esac);
            else
                OK (Nodes [obj]);
            fi;
        esac
    );

// [7] predicateObjectList ::= 	verb objectList (';' (verb objectList)?)*
// NB we permit an empty list here; caller must reject if its rule
// demands predicateObjectList rather than predicateObjectList?
predicateObjectList state =
   (sub acc state =
        if (chomp state; state.reader.next == ".") then
            OK (POList acc) // empty list, or ending with ; .
        else
            verb state ~>
               \case of
                IRI iri:
                    objectList state ~>
                       \case of Nodes nodes:
                            OK (POList (acc ++
                                        map do n: { p = IRI iri, o = n } done
                                            nodes));
                        esac;
                _: // e.g. boolean literal, base/prefix
                    Error "Expected IRI before \(state.reader.location)";
                esac ~>
                   \case of POList lst:
                        if (chomp state; state.reader.next == ";") then
                            state.reader.discard ();
                            sub lst state
                        else
                            OK (POList lst)
                        fi;
                    esac;
        fi;
    sub [] state);

// blankNodePropertyList ::= '[' predicateObjectList ']'
//!!! this currently allows an empty list, not permitted by spec -- check on ANON production though too
blankNodePropertyList state =
    punctuation "[" state ~>
      \(predicateObjectList state ~>
           \case of POList polist:
               (bnode = newBlankNode state;
                emitWithSubject state bnode polist ~>
                   \(punctuation "]" state) ~>
                       \(OK (Node bnode)));
            esac;
        );

blankNodePropertyList' := blankNodePropertyList;

// [6] triples ::= subject predicateObjectList | blankNodePropertyList predicateObjectList?
// Handles the blankNodePropertyList part of that alternation
blankNodeTriples state = 
    blankNodePropertyList state ~> 
       \case of Node subj:
            predicateObjectList state ~>
               \case of POList polist:
                    emitWithSubject state subj polist;
                esac;
        esac;

// [6] triples ::= subject predicateObjectList | blankNodePropertyList predicateObjectList?
// Handles the subject part of that alternation
subjectTriples state =
    subject state ~> 
       \case of
        Node subj:
            predicateObjectList state ~>
               \case of
                POList []:
                    Error "Predicate required after subject at \(state.reader.location)";
                POList polist:
                    emitWithSubject state subj polist;
                esac;
        BaseLabel ():
            sparqlBase state ~> \(OK ());
        PrefixLabel ():
            sparqlPrefix state ~> \(OK ());
        esac;

triples state = 
    case state.reader.next of
    "[": blankNodeTriples state;
      _: subjectTriples state;
    esac;

// [2] statement ::= directive | triples '.'
statement state =
   (chomp state;
    if state.reader.isEof then End ()
    else
        case state.reader.next of
        "@": directive state;
          _: triples state ~> \(punctuation "." state);
        esac;
    fi);

document state =
   (result = statement state;
    tt = map Triple state.pendingTriples;
    clearArray state.pendingTriples;
    case result of
    OK (Empty ()): (Triples tt) :. \(document state);
    Error e: [Error e];
    End _: [];
    esac);

// Flatten out [Triples [Triple, ...], Triples [Triple, ...], Error ...]
// into [Triple ..., Triple ..., Error ...]
flattened doc currentTriples =
    case currentTriples of
    t::tt:
        t :. \(flattened doc tt);
    _:
        case doc of
        element::ee:
            case element of
            Error e: [Error e];
            Triples chunk: flattened ee chunk;
            esac;
        _: [];
        esac;
    esac;

newState reader =
   (var nextBnode = 0;
    {
        reader,
        var base = "",
        pendingTriples = array [],
        namespaces = [:],
        bnodeLabels = [:],
        get newBlankNodeId () =
           (nextBnode := nextBnode + 1;
            nextBnode);
    });

parse reader =
    flattened (document (newState reader)) [];

parseHandle handle = 
    parse (char.reader handle);

parseFile filename = 
    parse (char.reader (openInFile filename "UTF-8")); // Turtle is always utf8

//!!! load to new store. loading into an existing store depends on proper global handling of blank nodes, which is still pending
loadFile filename = 
   (st = store.newStore ();
    fold
        do acc item:
            case acc of
            Error e: Error e;
            OK ():
                case item of
                Error e: Error e;
                Triple t:
                    if store.add st t then OK ()
                    else Error "Add failed for triple \(t)" fi;
                esac
            esac   
        done
        (OK ())
        (parseFile filename)
    ~> \(Store st));

{ parseHandle, parseFile, loadFile }
