
module yertle.index;

typedef statement = array<'a>;

typedef pattern = array<'a>;

typedef indextree = hash<'a, Sub 'b | Entry 'c>;

typedef index = { order is list<number>, tree is indextree };

newIndex order = { order, tree = [:] };

add ix stmt is index -> statement -> boolean =
    case ix.order of
    key::rest:
        node = stmt[key];
        if not node in ix.tree then 
            if empty? rest then 
                ix.tree[node] := Entry stmt;
                true;
            else
                sub = [:];
                ix.tree[node] := Sub sub;
                add { order = rest, tree = sub } stmt;
            fi;
        else
            case ix.tree[node] of
                Sub sub: add { order = rest, tree = sub } stmt;
                Entry s: empty? rest and s == stmt;
            esac;
        fi;
    _: false;
    esac;

remove ix stmt is index -> statement -> boolean =
    case ix.order of
    key::rest:
        node = stmt[key];
        if not node in ix.tree then false 
        else
            case ix.tree[node] of
                Sub sub: remove { order = rest, tree = sub } stmt;
                Entry s: empty? rest and (delete ix.tree node; true);
            esac;
        fi;
    _: false;
    esac;

enumerate' tree is 'a -> list<statement> =
    concat
       (map do k:
            case tree[k] of
            Sub sub: enumerate' sub;
            Entry e: [e];
            esac
        done (keys tree));

enumerate ix is index -> list<statement> =
    enumerate' ix.tree;

match ix pat is index -> pattern -> list<statement> =
    concat
       (case ix.order of
        key::rest:
           (matching = case pat[key] of
                       Wildcard _: keys ix.tree;
                       Known node: if node in ix.tree then [node] else [] fi;
                       esac;
            map do m:
                case ix.tree[m] of
                Sub sub: match { order = rest, tree = sub } pat;
                Entry e: [e];
                esac
            done matching);
        _: [];
        esac);

contains ix stmt is index -> statement -> boolean =
    not empty?
       (match ix (array (map Known stmt)));

scoreIndexFor pat order is pattern -> 'b -> number =
    case order of
    key::rest:
        case pat[key] of
        Wildcard _: 0;
        Known _: 16;
        esac + (scoreIndexFor pat rest) / 2;
    _: 0;
    esac;

chooseIndex ixs pat is list<index> -> pattern -> index =
   (h = mapIntoHash ((scoreIndexFor pat) . (.order)) id ixs;
    best = head (sortBy (>) (keys h));
    h[best]);

{ newIndex, add, remove, enumerate, contains, match, chooseIndex }


