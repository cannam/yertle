
module yertle.parsebits;

whitespace state =
   (r = state.reader;
    r.isWhitespace and not r.isEof loop r.discard ();
    if r.next == "#" then
        not r.isEol and not r.isEof loop r.discard ();
        whitespace state
    else
        OK (Empty ())
    fi);

chomp state = // read whitespace, discard, and return nothing
   (case whitespace state of OK _: (); esac);

required expected state =
    if state.reader.next == expected then
       state.reader.discard (); OK (Empty ());
    else
       Error "Expected '\(expected)', found '\(state.reader.next)' at \(state.reader.location)";
    fi;

greedy re state =
   (var tok = "";
    state.reader.next =~ re loop tok := tok ^ (state.reader.read ());
    OK (Token tok));

// Given result a and function b, if a is an Error, return that
// error; if a is an OK, pass its value to b and return that
(~>) a b is 'a -> 'b -> (OK 'c | Error 'd) =
    case a of
    OK result: b result;
    Error e: Error e;
    esac;

noseq state seq =
    case seq of
    f::rest: f state ~> \(noseq state rest);
    _: OK (Empty ());
    esac;

tokseq state seq =
   (sub acc state seq =
        case seq of
        f::rest:
            f state ~>
           \case of
            Token t: sub (OK (Token t)) state rest;
                  _: sub acc state rest;
            esac;
        _: acc;
        esac;
    sub (Error "No token found at \(state.reader.location)") state seq);

{ whitespace, chomp, required, greedy, ~>, noseq, tokseq }

