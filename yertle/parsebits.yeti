
module yertle.parsebits;

whitespace state =
   (r = state.reader;
    r.isWhitespace and not r.isEof loop r.discard ();
    if r.next == "#" then
        not r.isEol and not r.isEof loop r.discard ();
        whitespace state
    else
        OK (Empty ())
    fi);

chomp state = // read whitespace, discard, and return nothing
   (case whitespace state of OK _: (); esac);

required expected state =
    if state.reader.next == expected then
       state.reader.discard (); OK (Empty ());
    else
       Error "Expected '\(expected)', found '\(state.reader.next)' at \(state.reader.location)";
    fi;

// Given result a and function b, if a is an Error, return that
// error; if a is an OK, pass its value to b and return that
(~>) a b =
    case a of
    OK result: b result;
    Error e: Error e;
    esac;

noseq state seq =
    case seq of
    f::rest: f state ~> \(noseq state rest);
    _: OK (Empty ());
    esac;

tokseq state seq =
   (tokseq' acc state seq =
        case seq of
        f::rest:
            f state ~>
           \case of
            Token t: tokseq' (OK (Token t)) state rest;
                  _: tokseq' acc state rest;
            esac;
        _: acc;
        esac;
    tokseq' (Error "No token found at \(state.reader.location)") state seq);

{ whitespace, chomp, required, ~>, noseq, tokseq }

