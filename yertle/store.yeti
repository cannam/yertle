
module yertle.store;

index = load yertle.index;

typedef fullnode =
    IRI string | Blank number |
        Literal { value is string, type is string, language is string };

typedef statement = {
    s is IRI string | Blank number,
    p is IRI string,
    o is fullnode,
};

typedef pattern = {
    s is Wildcard () | Known (IRI string | Blank number),
    p is Wildcard () | Known (IRI string),
    o is Wildcard () | Known fullnode,
};

typedef indextree = hash<fullnode,
                         Sub hash<fullnode,
                                  Sub hash<fullnode,
                                           Entry array<fullnode>>>>;

typedef index = {
    order is list<number>, tree is indextree
};

typedef storetype = {
    indexes is list<index>,
};

newStore () = 
   (desired = [ "spo", "pos", "ops" ];
    nodemap = [ "s": 0, "p": 1, "o": 2 ];
    {
        indexes =
            map do name:
                index.newIndex (map (at nodemap) (tail (strSplit "" name)))
                done
                desired
    }
    );

indexable t = array [ t.s, t.p, t.o ];

deindex tt = { s = tt[0], p = tt[1], o = tt[2] };

add st t =
   (tt = indexable t;
    all id (map do ix: index.add ix tt done st.indexes));

remove st t =
   (tt = indexable t;
    all id (map do ix: index.remove ix tt done st.indexes));

enumerate st =
    map deindex (index.enumerate (head st.indexes));

contains st t =
    // Doesn't matter which index we use to look up a complete statement
    index.contains (head st.indexes) (indexable t);

match st pat =
   (tt = indexable pat;
    map deindex (index.match (index.chooseIndex st.indexes tt) tt));

typedef opaque store = storetype;

{ newStore, add, remove, enumerate, contains, match }
as
{
newStore is () -> store,
add is store -> statement -> boolean,
remove is store -> statement -> boolean,
enumerate is store -> list<statement>,
contains is store -> statement -> boolean,
match is store -> pattern -> list<statement>
}


