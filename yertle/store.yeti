
module yertle.store;

index = load yertle.index;

typedef statement = hash<string, IRI string | Blank number | Literal { value is string, type is string }>;

typedef store = {
    indexes is list<{ order is list<string>, tree is hash<'b, 'c> }>,
};

newStore () = {
    indexes = map do n: index.newIndex (tail (strSplit "" n)) done 
        [ "spo", "pos", "ops" ];
};

add st t is store -> statement -> boolean =
    all id (map do ix: index.add ix t done st.indexes);

remove st t is store -> statement -> boolean = 
    all id (map do ix: index.remove ix t done st.indexes);

enumerate st is store -> list<'a> =
    index.enumerate (head st.indexes);

contains st t is store -> statement -> boolean = 
    // Doesn't matter which index we use to look up a complete statement
    index.contains (head st.indexes) t;

match st pat is store -> statement -> list<statement> =
    index.match (index.chooseIndex st.indexes pat) pat;

triple a b c is 'a -> 'b -> 'c -> statement =
    [ "s" : a, "p" : b, "o" : c ];

{ newStore, add, remove, enumerate, contains, match, triple }


