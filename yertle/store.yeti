
module yertle.store;

index = load yertle.index;

typedef fullnode =
    IRI string | Blank number | Literal { value is string, type is string };

typedef statement = {
    s is IRI string | Blank number,
    p is IRI string,
    o is fullnode,
};

typedef pattern = {
    s is Wildcard () | IRI string | Blank number,
    p is Wildcard () | IRI string,
    o is Wildcard () | IRI string | Blank number | Literal { value is string, type is string },
};

typedef indextree = hash<fullnode,
                         Sub hash<fullnode,
                                  Sub hash<fullnode,
                                           Entry hash<string, fullnode>>>>;

typedef index = {
    order is list<string>, tree is indextree
};

typedef storetype = {
    indexes is list<index>,
};

newStore () = {
    indexes = map do n: index.newIndex (tail (strSplit "" n)) done 
        [ "spo", "pos", "ops" ];
};

hashOfStatement t =
    [ "s": t.s, "p": t.p, "o": t.o ];

statementOfHash h =
    { s = h["s"], p = h["p"], o = h["o"] };

hashOfPattern pat =
   (h = [:];
    kmap = [ (.s): "s", (.p): "p", (.o): "o" ];
    for (keys kmap) do sel:
        case sel pat of
        Wildcard _: ();
        other: h[kmap[sel]] := other;
        esac
    done;
    h);

add st t =
   (h = hashOfStatement t;
    all id (map do ix: index.add ix h done st.indexes));

remove st t =
   (h = hashOfStatement t;
    all id (map do ix: index.remove ix h done st.indexes));

enumerate st =
    map statementOfHash (index.enumerate (head st.indexes));

contains st t =
    // Doesn't matter which index we use to look up a complete statement
    index.contains (head st.indexes) (hashOfStatement t);

match st pat =
   (h = hashOfPattern pat;
    map statementOfHash (index.match (index.chooseIndex st.indexes h) h));

typedef opaque store = storetype;

{ newStore, add, remove, enumerate, contains, match }
as
{
newStore is () -> store,
add is store -> statement -> boolean,
remove is store -> statement -> boolean,
enumerate is store -> list<statement>,
contains is store -> statement -> boolean,
match is store -> pattern -> list<statement>
}


