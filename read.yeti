
module read;

char = load char;

load parsebits;

xsdPrefix = "http://www.w3.org/2001/XMLSchema#";
rdfPrefix = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
rdfTypeIRI  = IRI "\(rdfPrefix)type";
rdfFirstIRI = IRI "\(rdfPrefix)first";
rdfRestIRI  = IRI "\(rdfPrefix)rest";
rdfNilIRI   = IRI "\(rdfPrefix)nil";

newLiteral string = { value = string, type = "", language = "" };

punctuation expected state =
    noseq state [whitespace, required expected];

langtag state =
   (sub state = 
        case greedy "[a-zA-Z]" state of
        OK (Token tag):
            if state.reader.next == "-" then
                tag ^ state.reader.read () ^ sub state
            else
                tag
            fi;
        esac;
        tokseq state [required "@", OK . Token . sub]);

iriref state =
    tokseq state [required "<",
                  greedy "[^\\x00-\\x20<>\"{}|^`\\\\]", //!!! " or UCHAR
                  required ">"];

// REs for prefix:local matching. Does not yet handle PLX (rule 169s)

pnBaseRange = "A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";

//!!! NB Yeti docs say it will optimise REs made from constant
//strings: how should we take advantage of that?
pnCharsBase = "[\(pnBaseRange)]";
pnCharsU    = "[\(pnBaseRange)_]";
pnChars     = "[\(pnBaseRange)_0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040-]";
pnPrefix    = "\(pnCharsBase)(?:(?:\(pnChars)|\\.)*\(pnChars))?";
bnode       = "(?:\(pnCharsU)|[0-9])(?:(?:\(pnChars)|\\.)*(?:\(pnChars)))?";
pnLocal     = "(?:\(pnCharsU)|[0-9:])(?:(?:\(pnChars)|\\.|:)*(?:\(pnChars)|:))?"; //!!! needs PLX
pname       = "(\(pnPrefix))?:(\(pnLocal))"; // NB this ?: is not like the rest

emit state triple =
    push state.pendingTriples triple;

emitWithSubject state subject polist =
   (for polist do po: emit state { s = subject, p = po.p, o = po.o } done;
    OK ());

pnameNS state =
    notWhitespace state ~>
       \case of
        Token t:
            if strEnds? t ":" then
                pfx = strLeft t ((strLength t) - 1);
                if pfx == "" or pfx =~ "^\(pnPrefix)$" then
                    OK (Token pfx)
                else
                    Error "Malformed prefix '\(pfx)' at \(state.reader.location)"
                fi
            else
                Error "Expected ':' at end of prefix before \(state.reader.location)"
            fi
        esac;
                   
prefix state =
    tokseq state [ whitespace, pnameNS ] ~>
       \case of Token pname:
            tokseq state [whitespace, iriref, punctuation "."] ~>
               \case of Token iri:
                    state.namespaces[pname] := iri;
                    OK (Empty ());
                esac;
        esac;
        
base state = 
    tokseq state [whitespace, iriref, punctuation "."] ~>
       \case of
        Token iri: 
            state.base := iri;
            OK (Empty ());
        esac;

directive state =
    langtag state ~>
       \case of
        Token "prefix": prefix state;
        Token "base": base state;
        Token t: Error "Expected prefix or base, found '\(t)'";
        esac;

prefixExpanded state text =
    case matchAll "^\(pname)$" M T text of
    [M [whole, prefix, local]]:
        if prefix in state.namespaces then
            OK (IRI (state.namespaces[prefix] ^ local));
        else
            Error "Unknown namespace prefix '\(prefix)' at \(state.reader.location)";
        fi;
    _: Error "Malformed prefixed name '\(text)' at \(state.reader.location)";
    esac;

prefixedName state =
    notWhitespace state ~>
       \case of
        Token t: prefixExpanded state t;
        esac;

aOrPrefixedName state =
    notWhitespace state ~>
       \case of
        Token "a": OK rdfTypeIRI;
        Token t: prefixExpanded state t;
        esac;

newBlankNode state =
    Blank state.newBlankNodeId;

blankNodeFor state b =
   (if not b in state.bnodeLabels then
        state.bnodeLabels[b] := newBlankNode state;
    fi;
    state.bnodeLabels[b]);

blank state =
    tokseq state [required '_', required ':', notWhitespace] ~>
       \case of
        Token b:
            if b =~ "^\(bnode)$" then
                OK (blankNodeFor state b)
            else
                Error "Malformed blank node label '\(b)' at \(state.reader.location)";
            fi;
        esac;

var object' state =
    Error "object' should have been reassigned";

//!!! This could be simpler
collection state =
   (readObjects acc state =
       (chomp state;
        if state.reader.next == ")" then
            OK acc
        else
            object' state ~> do obj: readObjects (acc ++ [obj]) state done
        fi);
    addObjects node state objects =
        case objects of
        obj::rest:
           (emit state { s = node, p = rdfFirstIRI, o = obj };
            if empty? rest then
                emit state { s = node, p = rdfRestIRI, o = rdfNilIRI };
            else
                nextNode = newBlankNode state;
                emit state { s = node, p = rdfRestIRI, o = nextNode };
                addObjects nextNode state rest;
            fi);
        _: ();
        esac;
    required "(" state ~>
       \(readObjects [] state ~>
            do objects:
            case objects of
            []: required ")" state ~> \(OK rdfNilIRI);
             _:
               (headnode = newBlankNode state;
                addObjects headnode state objects;
                required ")" state ~> \(OK headnode));
            esac done));

booleanType =
    "\(xsdPrefix)boolean";

booleanLiteral state =
    greedy "[a-z]" state ~>
       \case of 
        Token  "true": OK (Literal (newLiteral "true" with { type = booleanType }));
        Token "false": OK (Literal (newLiteral "false" with { type = booleanType }));
        _: Error "Expected 'true' or 'false' at \(state.reader.location)";
        esac;

var datatype' state =
    Error "datatype' should have been reassigned";

//!!! doesn't handle multi-line literals (''' or """), escapes, \u \U
rdfLiteral state =
   (quote = state.reader.next;
    if quote != '"' and quote != "'" then //"
        Error "Expected quotation mark at \(state.reader.location)";
    else
        state.reader.discard ();
        tokseq state [ greedy "[^\\x5c\\x0a\\x0d\(quote)]", required quote ] ~>
           \case of
            Token t:
                case state.reader.next of
                "@": langtag state ~>
                       \case of Token lt:
                            OK (Literal (newLiteral t with { language = lt }));
                        esac;
                "^": datatype' state ~>
                       \case of IRI di:
                            OK (Literal (newLiteral t with { type = di }));
                        esac;
                  _: OK (Literal (newLiteral t));
                esac;
            esac;
    fi);

numericLiteral state =
    try
        greedy "[0-9eE+-]" state ~> 
           \case of
            Token n:
                type = if n =~ "[Ee]" then "\(xsdPrefix)double"
                       elif n =~ "\\." then "\(xsdPrefix)decimal"
                       else "\(xsdPrefix)integer"
                       fi;
                OK (Literal (newLiteral "\(number n)" with { type }));
            esac;
    catch NumberFormatException _:
        Error "Malformed numeric literal at \(state.reader.location)";
    yrt;

// [13] literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
literal state =
    case state.reader.next of
    "'": rdfLiteral state;
    '"': rdfLiteral state;   // "
    "t": booleanLiteral state;
    "f": booleanLiteral state;
      _: numericLiteral state;
    esac;

// [135s] iri ::= IRIREF | PrefixedName
iri state =
    case state.reader.next of
    "<": iriref state ~> \case of Token t: OK (IRI t); esac;
      _: prefixedName state;
    esac;

// [9] verb ::= predicate | 'a'
// where
// [11] predicate ::= iri
verb state =
    case state.reader.next of
    "<": iri state;
      _: aOrPrefixedName state;
    esac;

// [10] subject ::= iri | blank
subject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
      _: iri state;
    esac ~> (OK . Node);

datatype state =
    required "^" state ~> \(required "^" state) ~> \(iri state);

datatype' := datatype;

var blankNodePropertyList' state = 
    Error "blankNodePropertyList' should have been reassigned";

nonLiteralObject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
    "[": blankNodePropertyList' state;
      _: iri state;
    esac ~> (OK . Node);

// [12] object ::= iri | blank | blankNodePropertyList | literal
object state =
    if state.reader.next =~ "[_(\\[<:\(pnCharsBase)]" then
        nonLiteralObject state
    else
        literal state ~> (OK . Node)
    fi;

object' := object;

// [8] objectList ::= object (',' object)*
//!!! not tail-recursive
objectList state =
   (chomp state;
    object state ~>
        do obj:
            chomp state;
            if state.reader.next == "," then
               (state.reader.discard ();
                objectList state ~>
                   \case of Nodes nodes:
                        OK (Nodes (obj::nodes));
                    esac);
            else
                OK (Nodes [obj]);
            fi;
        done
    );

// [7] predicateObjectList ::= verb objectList (';' predicateObjectList?)*
predicateObjectList' acc state =
   (chomp state;
    verb state ~>
       \case of IRI iri:
            objectList state ~>
               \case of Nodes nodes:
                    OK (POList (acc ++ map do n: { p = IRI iri, o = n } done nodes));
                esac;
        esac ~>
           \case of POList lst:
               (chomp state;
                if state.reader.next == ";" then
                   (state.reader.discard ();
                    predicateObjectList' lst state)
                else
                    OK (POList lst)
                fi);
            esac;
    );

predicateObjectList state =
    predicateObjectList' [] state;

blankNodePropertyList state =
    punctuation "[" state ~>
      \(predicateObjectList state ~>
           \case of POList polist:
               (bnode = newBlankNode state;
                emitWithSubject state bnode polist ~>
                   \(punctuation "]" state) ~>
                       \(OK (Node bnode)));
            esac;
        );

blankNodePropertyList' := blankNodePropertyList;

emitNode state node =
    case node of Node subj:
        predicateObjectList state ~>
           \case of POList polist:
                emitWithSubject state subj polist;
            esac;
    esac;

blankNodeTriples state = 
    blankNodePropertyList state ~> emitNode state;

subjectTriples state =
    subject state ~> emitNode state;

triples state = 
    case state.reader.next of
    "[": blankNodeTriples state;
      _: subjectTriples state;
    esac;

statement state =
   (chomp state;
    if state.reader.isEof then End ()
    else
        case state.reader.next of
        "@": directive state;
          _: triples state ~> \(punctuation "." state);
        esac;
    fi);

document state =
   (result = statement state;
    tt = map Triple state.pendingTriples;
    clearArray state.pendingTriples;
    case result of
    OK (Empty ()): (Triples tt) :. \(document state);
    Error e: [Error e];
    End _: [];
    esac);

// Flatten out [Triples [...], Triples [...], Error ...]
// into [Triple ..., Triple ..., Error ...]
parse' doc currentTriples =
    case currentTriples of
    t::tt:
        t :. \(parse' doc tt);
    _:
        case doc of
        element::ee:
            case element of
            Error e: [Error e];
            Triples chunk: parse' ee chunk;
            esac;
        _: [];
        esac;
    esac;

newState reader =
   (var nextBnode = 0;
    {
        reader,
        var base = "",
        pendingTriples = array [],
        namespaces = [:],
        bnodeLabels = [:],
        get newBlankNodeId () =
           (nextBnode := nextBnode + 1;
            nextBnode);
    });

parse reader =
    parse' (document (newState reader)) [];

parseHandle handle = 
    parse (char.reader handle);

parseFile filename = 
    parse (char.reader (openInFile filename "UTF-8")); // Turtle is always utf8

{ parseHandle, parseFile }
