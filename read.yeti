
module read;

char = load char;

load parsebits;

punctuation expected r =
    noseq r [whitespace, required expected];

langtag r =
   (sub r = 
        case greedy "[a-zA-Z]" r of
        OK (Token tag):
            if r.next == "-" then tag ^ r.read () ^ sub r
            else tag
            fi;
        esac;
    tokseq r [required "@", OK . Token . sub]);

iriref r =
    tokseq r [required "<",
              greedy '[^\x00-\x20<>\\"{}|^`\\\\]', //!!! " or UCHAR
              required ">"];
        
base state r = 
    tokseq r [whitespace, iriref, punctuation "."] ~>
       \case of
        Token iri: OK (State (state with { base = iri }));
        esac;

pnBaseRange =
    "A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";

pnCharsBase = 
    "[\(pnBaseRange)]";

pnCharsU = 
    "[\(pnBaseRange)_:]";

pnChars = 
    "[\(pnBaseRange)_:0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040-]";

prefix state r =
    tokseq r [whitespace,
              greedy pnCharsBase, //!!! not correct for PN_PREFIX
              required ":", whitespace] ~>
       \case of Token pname:
            tokseq r [iriref, punctuation "."] ~>
               \case of Token iri:
                    OK (State (state with {
                        namespaces =
                            (h = copy (state.namespaces); h[pname] := iri; h)
                        }));
                esac;
        esac;

directive state r =
    langtag r ~>
       \case of
        Token "prefix": prefix state r;
        Token "base": base state r;
        Token t: Error "Expected prefix or base, found '\(t)'";
        esac;

prefixedNameLocal r =
    greedy pnCharsU r; //!!! not correct

prefixedName state r =
    tokseq r
        [greedy pnCharsBase, //!!! not correct
         required ":"] ~>
       \case of Token pname:
            if pname in state.namespaces then
                prefixedNameLocal r ~>
                   \case of Token local:
                        OK (IRI (state.namespaces[pname] ^ local));
                    esac
            else
                Error "Unknown namespace prefix '\(pname)' at \(r.location)";
            fi;
        esac;

blank state r =
    Error "blank not implemented at \(r.location)";

collection state r =
    Error "collection not implemented at \(r.location)";

literal state r =
    Error "literal not implemented at \(r.location)";

iri state r =
    case r.next of
    "<": iriref r ~> \case of Token t: OK (IRI t); esac;
      _: prefixedName state r;
    esac;
/*
subject state r =
   (node = case r.next of
    "_": blank state r;
    "(": collection state r;
      _: iri state r;
    esac;
    case node of Error e: Error e; _: OK (Node node); esac);
*/
subject state r =
    case r.next of
    "_": blank state r;
    "(": collection state r;
      _: iri state r;
    esac ~> (OK . Node);

predicate =
    iri;

blankNodePropertyList state r =
    Error "blankNodePropertyList not implemented at \(r.location)";

verb state r =
   (i = iri state r; //!!! wrong -- can be IRI or "a" -- how to handle this?
    println "read verb: \(i)";
    i);

object state r =
    case r.next of
    "_": blank state r;
    "(": collection state r;
    "[": blankNodePropertyList state r;    
    "<": iri state r;
    ":": iri state r;
      _: if r.next =~ pnCharsBase then iri state r
         else literal state r
         fi;
    esac ~> (OK . Node);
/*
objectNodeList state r =
   (obj = object state r;
    case obj of Error _: obj;
    Node node:
       (chomp r;
        if r.next == "," then
            r.discard ();
            obj :: objectNodeList state r;
        else
            [obj]
        fi);
    esac);
*/
objectList state r =
    Error "objectList not implemented";    

predicateObjectList state r =
// Not right: predicateObjectList ::= verb objectList (';' predicateObjectList?)*
// but this only reads one verb objectList
   (chomp r;
    verb state r ~>
       \case of IRI iri:
            objectList state r ~>
               \case of Nodes nodes:
                    OK (POList
                        (map \case of Node node: { p = iri, o = node } esac
                              nodes));
                esac;
        esac);

blankNodeTriples state r = 
    blankNodePropertyList state r ~>
       \case of Triples tt:
           (subj = (head tt).s;
            predicateObjectList state r ~>
               \case of POList polist:
                    OK (Triples
                        (map do po: { s = subj, p = po.p, o = po.o } done
                             polist));
                esac
            );
        esac;

subjectTriples state r =
    subject state r ~>
       \case of Node subj:
            predicateObjectList state r ~>
               \case of POList polist:
                    if empty? polist then
                        Error "At least one predicate expected at \(r.location)"
                    else
                        OK (Triples
                            (map do po: { s = subj, p = po.p, o = po.o } done
                                 polist))
                    fi;
                esac;
        esac;

triples state r = 
    case r.next of
    "[": blankNodeTriples state r;
      _: subjectTriples state r;
    esac;

statement state r =
   (chomp r;
    if r.isEof then End ()
    else
        case r.next of
        "@": directive state r;
          _: triples   state r;
        esac;
    fi);

document state r =
   (println "state = \(state)";
    result = statement state r;
    case result of
    OK (State newstate):
        document newstate r;
    OK (Triples t):
        result :. \(document state r);
    Error text:
        [result];
    End _:
        [];
    esac);

parse =
    document {
        base = "",
        namespaces = [:],
        bnodeLabels = [:],
    };

parseHandle handle = 
    parse (char.reader handle);

parseFile filename = 
    parse (char.reader (openInFile filename "UTF-8")); // Turtle is always utf8

{ parseHandle, parseFile }
