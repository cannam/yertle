
module read;

char = load char;

whitespace r =
   (r.isWhitespace loop r.discard ();
    if r.next == "#" then
        not r.isEol loop r.discard ();
        whitespace r;
    else
        OK ()
    fi);

required expected r =
    if r.next == expected then
       r.discard (); OK ()
    else
       Error "Expected '\(expected)', found '\(r.next)' at \(r.location)";
    fi;

greedy re r =
   (var tok = "";
    r.next =~ re loop tok := tok ^ (r.read ());
    Token tok);

/**
 * Sequence of matches, of which at most one can be a token
 * match.
 *
 * r is a reader; seq is a list of functions that take the
 * reader as arg and each return Token, OK, or Error.
 *
 * Result is Error if any function in seq returns Error; else
 * Token if one function in seq returns Token; else OK.
 */
sequence r seq =
   (sub acc r seq =
        case seq of
        h::t:
           (item = h r;
            case item of
            Error _: item;
            Token _: sub item r t;
               OK _: sub acc r t;
            esac);
        _: acc;
        esac;
    sub (OK ()) r seq);

/**
 * Sequence returning a single token, or error
 */
tokseq r seq =
    case sequence r seq of
    OK _: Error "Token expected around \(r.location)";
    Token t: Token t;
    Error e: Error e;
    esac;

punctuation expected r =
    sequence r
       [whitespace,
        required expected];

langtag r =
   (sub r = 
        case greedy "[a-zA-Z]" r of
        Token tag:
            if r.next == "-" then tag ^ r.read () ^ sub r
            else tag
            fi;
        esac;
    tokseq r
       [required "@",
        Token . sub]);

iriref r =
    tokseq r
       [required "<",
        greedy '[^\x00-\x20<>\\"{}|^`\\\\]', //!!! " or UCHAR
        required ">"];

ifgood a b =
    case a of
    Error e: Error e;
          _: b;
    esac;

base state r = 
    case tokseq r
       [whitespace,
        iriref]
    of
        Token iri: State (state with { base = iri });
        Error e: Error "Failed to read @base: \(e)";
    esac;

prefix state r =
    case tokseq r
       [whitespace,
        greedy "[a-zA-Z]", //!!! not correct for PN_PREFIX
        required ":",
        whitespace]
    of
    Token pname:
        case iriref r of
        Token iri: State (state with {
            namespaces = (h = copy (state.namespaces); h[pname ^ ":"] := iri; h)
            });
        Error e: Error "Failed to read prefix IRI: \(e)";
        esac;
    Error e: Error "Failed to read prefix name: \(e)";
    esac;

directive state r =
   (case langtag r of
    Token t:
        case t of
        "prefix": prefix state r;
          "base": base state r;
               _: Error "Expected prefix or base, found '\(t)'";
        esac;
    Error e: Error "Failed to read directive: \(e)";
    esac);

triples state r = Triples [];

statement state r =
    case whitespace r of OK _:
        if r.isEof then End ()
        else
            result = case r.next of
            "@": directive state r;
              _: triples   state r;
            esac;
            ifgood result (ifgood (punctuation "." r) result);
        fi;
    esac;

document state r =
   (println "state = \(state)";
    result = statement state r;
    case result of
    State newstate:
        document newstate r;
    Triples t:
        result :. \(document state r);
    Error text:
        [result];
    End _:
        [];
    esac);

readDocument handle = 
    document {
        base = "",
        namespaces = [:],
        bnodeLabels = [:],
//        curSubject = "",
//        curPredicate = ""
    } (char.reader handle);

{ readDocument }
