
module read;

char = load char;

load parsebits;

rdfTypeIRI = IRI "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
xsdPrefix = IRI "http://www.w3.org/2001/XMLSchema#";

newLiteral string = { value = string, type = "", language = "" };

punctuation expected state =
    noseq state [whitespace, required expected];

langtag state =
   (sub state = 
        case greedy "[a-zA-Z]" state of
        OK (Token tag):
            if state.reader.next == "-" then
                tag ^ state.reader.read () ^ sub state
            else
                tag
            fi;
        esac;
        tokseq state [required "@", OK . Token . sub]);

iriref state =
    tokseq state [required "<",
                  greedy "[^\\x00-\\x20<>\"{}|^`\\\\]", //!!! " or UCHAR
                  required ">"];

// REs for prefix:local matching. Does not yet handle PLX (rule 169s)

pnBaseRange = "A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";

//!!! NB Yeti docs say it will optimise REs made from constant
//strings: how should we take advantage of that?
pnCharsBase = "[\(pnBaseRange)]";
pnCharsU    = "[\(pnBaseRange)_]";
pnChars     = "[\(pnBaseRange)_0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040-]";
pnPrefix    = "\(pnCharsBase)(?:(?:\(pnChars)|\\.)*\(pnChars))?";
bnode       = "(?:\(pnCharsU)|[0-9])(?:(?:\(pnChars)|\\.)*(?:\(pnChars)))?";
pnLocal     = "(?:\(pnCharsU)|[0-9:])(?:(?:\(pnChars)|\\.|:)*(?:\(pnChars)|:))?"; //!!! needs PLX
pname       = "(\(pnPrefix))?:(\(pnLocal))"; // NB this ?: is not like the rest

pnameNS state =
    notWhitespace state ~>
       \case of
        Token t:
            if strEnds? t ":" then
                pfx = strLeft t ((strLength t) - 1);
                if pfx == "" or pfx =~ "^\(pnPrefix)$" then
                    OK (Token pfx)
                else
                    Error "Malformed prefix '\(pfx)' at \(state.reader.location)"
                fi
            else
                Error "Expected ':' at end of prefix before \(state.reader.location)"
            fi
        esac;
                   
prefix state =
    tokseq state [ whitespace, pnameNS ] ~>
       \case of Token pname:
            tokseq state [whitespace, iriref, punctuation "."] ~>
               \case of Token iri:
                    OK (State (state with {
                        namespaces =
                            (h = copy (state.namespaces); h[pname] := iri; h)
                        }));
                esac;
        esac;
        
base state = 
    tokseq state [whitespace, iriref, punctuation "."] ~>
       \case of
        Token iri: OK (State (state with { base = iri }));
        esac;

directive state =
    langtag state ~>
       \case of
        Token "prefix": prefix state;
        Token "base": base state;
        Token t: Error "Expected prefix or base, found '\(t)'";
        esac;

prefixExpanded state text =
    case matchAll "^\(pname)$" M T text of
    [M [whole, prefix, local]]:
        if prefix in state.namespaces then
            OK (IRI (state.namespaces[prefix] ^ local));
        else
            Error "Unknown namespace prefix '\(prefix)' at \(state.reader.location)";
        fi;
    _: Error "Malformed prefixed name '\(text)' at \(state.reader.location)";
    esac;

prefixedName state =
    notWhitespace state ~>
       \case of
        Token t: prefixExpanded state t;
        esac;

aOrPrefixedName state =
    notWhitespace state ~>
       \case of
        Token "a": OK rdfTypeIRI;
        Token t: prefixExpanded state t;
        esac;

blankNodeFor state b =
//!!! oops -- this doesn't square with the way other functions work --
//elsewhere we return either Token (etc) or State, and update the
//state back in the dispatcher if State is returned. But this one
//needs to return both something-parsed and a new state, so we can't
//do that here.
   (if not b in state.bnodeLabels then
        state.bnodeLabels[b] := state.nextBnode;
        state.nextBnode := state.nextBnode + 1;
    fi;
    Blank state.bnodeLabels[b]);

blank state =
    tokseq state [required '_', required ':', notWhitespace] ~>
       \case of
        Token b:
            if b =~ "^\(bnode)$" then
                OK (blankNodeFor state b)
            else
                Error "Malformed blank node label '\(b)' at \(state.reader.location)";
            fi;
        esac;

collection state =
    Error "collection not implemented at \(state.reader.location)";

booleanType =
    "\(xsdPrefix)boolean";

booleanLiteral state =
    greedy "[a-z]" state ~>
       \case of 
        Token  "true": OK (Literal (newLiteral "true" with { type = booleanType }));
        Token "false": OK (Literal (newLiteral "false" with { type = booleanType }));
        _: Error "Expected 'true' or 'false' at \(state.reader.location)";
        esac;

//!!! doesn't handle multi-line literals (''' or """), escapes, \u \U,
//languages, datatype etc
rdfLiteral state =
   (quote = state.reader.next;
    if quote != '"' and quote != "'" then //"
        Error "Expected quotation mark at \(state.reader.location)";
    else
        state.reader.discard ();
        tokseq state [ greedy "[^\\x5c\\x0a\\x0d\(quote)]", required quote ] ~>
           \case of
            Token t:
                case langtag state of
                OK (Token lt): OK (Literal (newLiteral t with { language = lt }));
                Error _: OK (Literal (newLiteral t));
                esac;
            esac;
    fi);

numericLiteral state =
    try
        greedy "[0-9eE+-]" state ~> 
           \case of
            Token n:
                type = if n =~ "[Ee]" then "\(xsdPrefix)double"
                       elif n =~ "\\." then "\(xsdPrefix)decimal"
                       else "\(xsdPrefix)integer"
                       fi;
                OK (Literal (newLiteral "\(number n)" with { type }));
            esac;
    catch NumberFormatException _:
        Error "Malformed numeric literal at \(state.reader.location)";
    yrt;

// [13] literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
literal state =
    case state.reader.next of
    "'": rdfLiteral state;
    '"': rdfLiteral state;   // "
    "t": booleanLiteral state;
    "f": booleanLiteral state;
      _: numericLiteral state;
    esac;

// [135s] iri ::= IRIREF | PrefixedName
iri state =
    case state.reader.next of
    "<": iriref state ~> \case of Token t: OK (IRI t); esac;
      _: prefixedName state;
    esac;

// [9] verb ::= predicate | 'a'
// where
// [11] predicate ::= iri
verb state =
    case state.reader.next of
    "<": iri state;
      _: aOrPrefixedName state;
    esac;

// [10] subject ::= iri | blank
subject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
      _: iri state;
    esac ~> (OK . Node);

var blankNodePropertyList' state = 
    Error "blankNodePropertyList' should have been reassigned";

nonLiteralObject state =
    case state.reader.next of
    "_": blank state ~> (OK . Node);
    "(": collection state;
    "[": blankNodePropertyList' state;
      _: iri state ~> (OK . Node);
    esac;

// [12] object ::= iri | blank | blankNodePropertyList | literal
object state =
    if state.reader.next =~ "[_(\\[<:\(pnCharsBase)]" then
        nonLiteralObject state
    else
        literal state ~> (OK . Node)
    fi;

// [8] objectList ::= object (',' object)*
//!!! not tail-recursive
objectList state =
   (chomp state;
    object state ~>
        do obj:
            chomp state;
            if state.reader.next == "," then
               (state.reader.discard ();
                objectList state ~>
                   \case of Nodes nodes:
                        OK (Nodes (obj::nodes));
                    esac);
            else
                OK (Nodes [obj]);
            fi;
        done
    );

// Take a mixture of nodes and triples (read from the object position
// in a triple -- we expect a node there, but in the case of nested
// blank nodes or collections we might get a whole set of triples) and
// convert the nodes to predicate-object pairs by inserting the verb
// into each. Triples lists we preserve unchanged, but we insert an
// additional triple associating the verb with the head triple in the
// list.
nodesToPOs acc verb nodes = //!!! don't like this name
    case nodes of
    n::rest:
        case n of
        Node node:
            nodesToPOs (acc ++ [PO { p = verb, o = node }]) 
                verb rest;
        Triples tt:
            nodesToPOs (acc ++ [PO { p = verb, o = (head tt).s },
                                Triples tt])
                verb rest;
        esac;
    _: acc;
    esac;

// [7] predicateObjectList ::= verb objectList (';' predicateObjectList?)*
predicateObjectList' acc state =
   (chomp state;
    verb state ~>
       \case of IRI iri:
            objectList state ~>
               \case of Nodes nodes:
                    OK (POList (nodesToPOs acc iri nodes));
                esac;
        esac ~>
           \case of POList lst:
               (chomp state;
                if state.reader.next == ";" then
                   (state.reader.discard ();
                    predicateObjectList' lst state)
                else
                    OK (POList lst)
                fi);
            esac;
    );

predicateObjectList state =
    predicateObjectList' [] state;

flattenAndAddSubject state subject polist = //!!! don't like this name
   (concat
       (map do entry:
            case entry of 
            PO po: [ { s = subject, p = po.p, o = po.o } ];
            Triples tt: tt;
            esac
            done polist)
    );

blankNodePropertyList state =
    punctuation "[" state ~>
      \(predicateObjectList state ~>
           \case of POList polist:
               (subj = Blank state.nextBnode; //!!! clean up, and see blankNodeFor above
                state.nextBnode := state.nextBnode + 1; //!!!
                punctuation "]" state ~>
                   \(OK (Triples (flattenAndAddSubject state subj polist)))
                );
            esac;
        );            

blankNodePropertyList' := blankNodePropertyList;

blankNodeTriples state = 
    blankNodePropertyList state ~>
       \case of Triples tt:
           (subj = (head tt).s;
            predicateObjectList state ~>
               \case of POList polist:
                    OK (Triples (tt ++ (flattenAndAddSubject state subj polist)))
                esac
            );
        esac;

subjectTriples state =
    subject state ~>
       \case of Node subj:
            predicateObjectList state ~>
               \case of POList polist:
                    OK (Triples (flattenAndAddSubject state subj polist))
                esac;
        esac;

triples state = 
    case state.reader.next of
    "[": blankNodeTriples state;
      _: subjectTriples state;
    esac;

statement state =
   (chomp state;
    if state.reader.isEof then End ()
    else
        case state.reader.next of
        "@":
            directive state;
          _:
            triples state ~>
               \case of
                Triples tt: punctuation "." state ~> \(OK (Triples tt));
                esac;
        esac;
    fi);

document state =
   (result = statement state;
    case result of
    OK (State newstate):
        document newstate;
    OK (Triples tt):
        (Triples tt) :. \(document state);
    Error e: [Error e];
    End _: [];
    esac);

// Flatten out [Triples [...], Triples [...], Error ...]
// into [Triple ..., Triple ..., Error ...]
parse' doc currentTriples =
    case currentTriples of
    t::tt:
        (Triple t) :. \(parse' doc tt);
    _:
        case doc of
        element::ee:
            case element of
            Error e: [Error e];
            Triples chunk: parse' ee chunk;
            esac;
        _: [];
        esac;
    esac;

parse reader =
    parse' (document {
        reader,
        base = "",
        namespaces = [:],
        bnodeLabels = [:],
        var nextBnode = 0, //!!! should be global within store
    }) [];

parseHandle handle = 
    parse (char.reader handle);

parseFile filename = 
    parse (char.reader (openInFile filename "UTF-8")); // Turtle is always utf8

{ parseHandle, parseFile }
