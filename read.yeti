
module read;

char = load char;

load parsebits;

rdfTypeIRI = IRI "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
xsdPrefix = IRI "http://www.w3.org/2001/XMLSchema#";

pnBaseRange =
    "A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";

pnCharsBase = 
    "[\(pnBaseRange)]";

pnCharsU = 
    "[\(pnBaseRange)_:]";

pnChars = 
    "[\(pnBaseRange)_:0-9\u00B7\u0300-\u036F\u203F-\u2040-]";

pnCharsNoColon = //!!! See comment at pnPrefix below
    "[\(pnBaseRange)_0-9\u00B7\u0300-\u036F\u203F-\u2040-]";

newLiteral string = { value = string, type = "", language = "" };

punctuation expected state =
    noseq state [whitespace, required expected];

langtag state =
   (sub state = 
        case greedy "[a-zA-Z]" state of
        OK (Token tag):
            if state.reader.next == "-" then
                tag ^ state.reader.read () ^ sub state
            else
                tag
            fi;
        esac;
        tokseq state [required "@", OK . Token . sub]);

iriref state =
    tokseq state [required "<",
                  greedy "[^\\x00-\\x20<>\"{}|^`\\\\]", //!!! " or UCHAR
                  required ">"];
        
base state = 
    tokseq state [whitespace, iriref, punctuation "."] ~>
       \case of
        Token iri: OK (State (state with { base = iri }));
        esac;

//!!! Ah, no -- we can't do this with only one char lookahead.
// A prefix can have a . in it, but not as the final character.
// Also, crazily, ":" appears to be permitted in a prefix!
// (as in @prefix myprefix:: <http://example.com/>)
// For now we'll just reject . and : in prefix string...
pnPrefix state =
    greedy pnCharsBase state ~>
       \case of Token base:
           greedy pnCharsNoColon state ~>
               \case of Token rest:
                OK (Token (base ^ rest));
                esac;
        esac;

prefix state =
    tokseq state [whitespace,
                  pnPrefix,
                  required ":", whitespace] ~>
       \case of Token pname:
            tokseq state [iriref, punctuation "."] ~>
               \case of Token iri:
                    OK (State (state with {
                        namespaces =
                            (h = copy (state.namespaces); h[pname] := iri; h)
                        }));
                esac;
        esac;

directive state =
    langtag state ~>
       \case of
        Token "prefix": prefix state;
        Token "base": base state;
        Token t: Error "Expected prefix or base, found '\(t)'";
        esac;

prefixedNameLocal state =
   \case of Token pname:
        if pname in state.namespaces then
            greedy pnCharsU state ~> //!!! not really right (for PN_LOCAL)
               \case of Token local:
                    OK (IRI (state.namespaces[pname] ^ local));
                esac
        else
            Error "Unknown namespace prefix '\(pname)' at \(state.reader.location)";
        fi;
    esac;

prefixedName state =
    tokseq state [pnPrefix, required ":"] ~>
        prefixedNameLocal state;

aOrPrefixedName state =
    greedy pnCharsBase state ~> //!!! not correct
       \case of Token pname:
            if state.reader.next == ":" then
               (state.reader.discard ();
                prefixedNameLocal state (Token pname));
            elif pname == "a" and state.reader.isWhitespace then
                OK rdfTypeIRI;
            else
                Error "Expected 'a' or prefix at \(state.reader.location)";
            fi
        esac;

blank state =
    Error "blank not implemented at \(state.reader.location)";

collection state =
    Error "collection not implemented at \(state.reader.location)";

booleanType =
    "\(xsdPrefix)boolean";

booleanLiteral state =
    greedy "[a-z]" state ~>
       \case of 
        Token  "true": OK (Literal (newLiteral "true" with { type = booleanType }));
        Token "false": OK (Literal (newLiteral "false" with { type = booleanType }));
        _: Error "Expected 'true' or 'false' at \(state.reader.location)";
        esac;

//!!! doesn't handle multi-line literals (''' or """), escapes, \u \U,
//languages, datatype etc
rdfLiteral state =
   (quote = state.reader.next;
    if quote != '"' and quote != "'" then //"
        Error "Expected quotation mark at \(state.reader.location)";
    else
        state.reader.discard ();
        tokseq state [ greedy "[^\\x5c\\x0a\\x0d\(quote)]", required quote ] ~>
           \case of
            Token t:
                case langtag state of
                OK (Token lt): OK (Literal (newLiteral t with { language = lt }));
                Error _: OK (Literal (newLiteral t));
                esac;
            esac;
    fi);

numericLiteral state =
    try
        greedy "[0-9eE+-]" state ~> 
           \case of
            Token n:
                type = if n =~ "[Ee]" then "\(xsdPrefix)double"
                       elif n =~ "\\." then "\(xsdPrefix)decimal"
                       else "\(xsdPrefix)integer"
                       fi;
                OK (Literal (newLiteral "\(number n)" with { type }));
            esac;
    catch NumberFormatException _:
        Error "Malformed numeric literal at \(state.reader.location)";
    yrt;

// [13] literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
literal state =
    case state.reader.next of
    "'": rdfLiteral state;
    '"': rdfLiteral state;   // "
    "t": booleanLiteral state;
    "f": booleanLiteral state;
      _: numericLiteral state;
    esac;

// [135s] iri ::= IRIREF | PrefixedName
iri state =
    case state.reader.next of
    "<": iriref state ~> \case of Token t: OK (IRI t); esac;
      _: prefixedName state;
    esac;

// [9] verb ::= predicate | 'a'
// where
// [11] predicate ::= iri
verb state =
    case state.reader.next of
    "<": iri state;
      _: aOrPrefixedName state;
    esac;

// [10] subject ::= iri | blank
subject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
      _: iri state;
    esac ~> (OK . Node);

blankNodePropertyList state =
    Error "blankNodePropertyList not implemented at \(state.reader.location)";

nonLiteralObject state =
    case state.reader.next of
    "_": blank state;
    "(": collection state;
    "[": blankNodePropertyList state;
      _: iri state;
    esac ~> (OK . Node);

// [12] object ::= iri | blank | blankNodePropertyList | literal
object state =
    if state.reader.next =~ "[_(\\[<:\(pnCharsBase)]" then
        nonLiteralObject state
    else
        literal state ~> (OK . Node)
    fi;

// [8] objectList ::= object (',' object)*
//!!! not tail-recursive
objectList state =
   (chomp state;
    object state ~>
       \case of Node n:
           (chomp state;
            if state.reader.next == "," then
               (state.reader.discard ();
                objectList state ~>
                   \case of Nodes nodes:
                        OK (Nodes ((Node n)::nodes));
                    esac);
            else
                OK (Nodes [Node n])
            fi);
        esac
    );

// [7] predicateObjectList ::= verb objectList (';' predicateObjectList?)*
//!!! Hm, this is not tail-recursive I think? and I don't like it
predicateObjectList' acc state =
   (chomp state;
    verb state ~>
       \case of IRI iri:
            objectList state ~>
               \case of Nodes nodes:
                    OK (POList
                        (acc ++
                         (map \case of Node node: { p = iri, o = node } esac
                              nodes)));
                esac;
        esac ~>
           \case of POList lst:
               (chomp state;
                if state.reader.next == ";" then
                   (state.reader.discard ();
                    predicateObjectList' lst state)
                else
                    OK (POList lst)
                fi);
            esac;
    );

predicateObjectList state =
   predicateObjectList' [] state;

blankNodeTriples state = 
    blankNodePropertyList state ~>
       \case of Triples tt:
           (subj = (head tt).s;
            predicateObjectList state ~>
               \case of POList polist:
                    OK (Triples
                        (map do po: { s = subj, p = po.p, o = po.o } done
                             polist));
                esac
            );
        esac;

subjectTriples state =
    subject state ~>
       \case of Node subj:
            predicateObjectList state ~>
               \case of POList polist:
                    if empty? polist then
                        Error "At least one predicate expected at \(state.reader.location)"
                    else
                        OK (Triples
                            (map do po: { s = subj, p = po.p, o = po.o } done
                                 polist))
                    fi;
                esac;
        esac;

triples state = 
    case state.reader.next of
    "[": blankNodeTriples state;
      _: subjectTriples state;
    esac;

statement state =
   (chomp state;
    if state.reader.isEof then End ()
    else
        case state.reader.next of
        "@":
            directive state;
          _:
            triples state ~>
               \case of
                Triples tt: punctuation "." state ~> \(OK (Triples tt));
                esac;
        esac;
    fi);

document state =
   (result = statement state;
    case result of
    OK (State newstate):
        document newstate;
    OK (Triples t):
        (Triples t) :. \(document state);
    Error e: [Error e];
    End _: [];
    esac);

// Flatten out [OK Triples [...], OK Triples [...], Error ...]
// into [Triple ..., Triple ..., Error ...]
parse' doc currentTriples =
    case currentTriples of
    t::tt:
        (Triple t) :. \(parse' doc tt);
    _:
        case doc of
        element::ee:
            case element of
            Error e: [Error e];
            Triples chunk: parse' ee chunk;
            esac;
        _: [];
        esac;
    esac;

parse reader =
    parse' (document {
        reader,
        base = "",
        namespaces = [:],
        bnodeLabels = [:],
    }) [];

parseHandle handle = 
    parse (char.reader handle);

parseFile filename = 
    parse (char.reader (openInFile filename "UTF-8")); // Turtle is always utf8

{ parseHandle, parseFile }
