
module read;

char = load char;

whitespace r =
   (r.isWhitespace loop r.discard ();
    if r.next == "#" then
        not r.isEol loop r.discard ();
        whitespace r;
    else
        OK ()
    fi);

required r expected =
    if r.next == expected then
       r.discard (); OK ()
    else
       Error "Expected '\(expected)', found '\(r.next)' at \(r.location)";
    fi;

greedy r re =
   (var tok = "";
    r.next =~ re loop tok := tok ^ (r.read ());
    Token tok);

/**
 * Sequence of matches, of which at most one can be a token
 * match. Returns token, OK, or error
 */
sequence _ =
   (sub acc seq =
        case seq of
        h::t:
           (item = h ();
            case item of
            Error _: item;
            Token _: sub item t;
               OK _: sub acc t;
            esac);
        _: acc;
        esac;
    sub (OK ()));            

/**
 * Sequence returning a single token, or error
 */
tokseq r seq =
    case sequence r seq of
    OK _: Error "Token expected around \(r.location)";
    Token t: Token t;
    Error e: Error e;
    esac;

punctuation r expected =
    sequence r
       [\(whitespace r),
        \(required r expected)];

langtag r =
   (sub r = 
        case greedy r "[a-zA-Z]" of
        Token tag:
            if r.next == "-" then tag ^ r.read () ^ sub r
            else tag
            fi;
        esac;
    tokseq r
       [\(required r "@"),
        \(Token (sub r))]);

iriref r =
    tokseq r
       [\(required r "<"),
        \(greedy r '[^\x00-\x20<>\\"{}|^`\\\\]'), //!!! " or UCHAR
        \(required r ">")];

ifgood a b =
    case a of
    Error e: Error e;
          _: b;
    esac;

base r state = 
    case tokseq r
       [\(whitespace r),
        \(iriref r)]
    of
        Token iri: State (state with { base = iri });
        Error e: Error "Failed to read @base: \(e)";
    esac;

prefix r state =
    case tokseq r
       [\(whitespace r),
        \(greedy r "[a-zA-Z]"), //!!! not correct for PN_PREFIX
        \(required r ":"),
        \(whitespace r)]
    of
    Token pname:
        case iriref r of
        Token iri: State (state with {
            namespaces = (h = copy (state.namespaces); h[pname ^ ":"] := iri; h)
            });
        Error e: Error "Failed to read prefix IRI: \(e)";
        esac;
    Error e: Error "Failed to read prefix name: \(e)";
    esac;

directive r state =
   (case langtag r of
    Token t:
        case t of
        "prefix": prefix r state;
          "base": base r state;
               _: Error "Expected prefix or base, found '\(t)'";
        esac;
    Error e: Error "Failed to read directive: \(e)";
    esac);

triples r state = Triples [];

statement r state =
    case whitespace r of OK _:
        if r.isEof then End ()
        else
            result = case r.next of
            "@": directive r state;
              _: triples   r state;
            esac;
            ifgood result (ifgood (punctuation r ".") result);
        fi;
    esac;

document r state =
   (println "state = \(state)";
    result = statement r state;
    case result of
    State newstate:
        document r newstate;
    Triples t:
        result :. \(document r state);
    Error text:
        [result];
    End _:
        [];
    esac);

readDocument handle = 
    document (char.reader handle) {
        base = "",
        namespaces = [:],
        bnodeLabels = [:],
//        curSubject = "",
//        curPredicate = ""
    };

{ readDocument }
