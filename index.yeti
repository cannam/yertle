
module index;

typedef stmt = {
   s is URI string | Blank number,
   p is URI string,
   o is URI string | Blank number | Literal { value is string, type is string },
};

typedef pattern = {
   s is Wildcard () | URI string | Blank number,
   p is Wildcard () | URI string,
   o is Wildcard () | URI string | Blank number | Literal { value is string, type is string }
};

typedef indextree = hash<'a, Sub 'b | Entry 'c>;

typedef index = { order is 'a, tree is indextree };

newIndex type = {
    order =
    case type of 
       SPO (): [ (.s), (.p), (.o) ]; // list of selectors must be exhaustive for the statement structure
       POS (): [ (.p), (.o), (.s) ];
       OPS (): [ (.o), (.p), (.s) ];
       Other o: o;
    esac,
    tree = [:];
};

add ix statement is index -> stmt -> boolean =
    case ix.order of
    selector::rest:
        node = selector statement;
        if not node in ix.tree then 
            if empty? rest then 
                ix.tree[node] := Entry statement;
                true;
            else
                sub = [:];
                ix.tree[node] := Sub sub;
                add { order = rest, tree = sub } statement;
            fi;
        else
            case ix.tree[node] of
                Sub sub: add { order = rest, tree = sub } statement;
                Entry s: empty? rest and s == statement;
            esac;
        fi;
    _: false;
    esac;

enumerate ix is index -> list<'a> =
    concat
       (map do k:
            case ix.tree[k] of
            Sub sub: enumerate { tree = sub };
            Entry e: [e];
            esac
        done (keys ix.tree));

contains ix statement is index -> stmt -> boolean =
    case ix.order of
    selector::rest:
        node = selector statement;
        if not node in ix.tree then false
        else
            case ix.tree[node] of
                Sub sub: contains { order = rest, tree = sub } statement;
                Entry s: s == statement;
            esac
        fi;
    _: false;
    esac;

{ newIndex, add, enumerate, contains }


